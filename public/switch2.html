<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch 2 Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #667eea;
            --primary-dark: #5a67d8;
            --secondary-color: #764ba2;
            --success-color: #48bb78;
            --warning-color: #ed8936;
            --danger-color: #f56565;
            --info-color: #4299e1;
            --light-bg: #f7fafc;
            --white: #ffffff;
            --gray-50: #f9fafb;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #9ca3af;
            --gray-500: #6b7280;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --border-radius-lg: 16px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            color: var(--gray-800);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-xl);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 400;
        }

        .grid {
            display: grid;
            gap: 24px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            margin-bottom: 24px;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        }

        .grid-3 {
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        @media (max-width: 1200px) {
            .grid-3 {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 768px) and (max-width: 1200px) {
            .grid-3 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 三列布局时的卡片内容优化 */
        .grid-3 .card {
            min-height: 300px;
        }

        .grid-3 .card .table {
            font-size: 0.85rem;
        }

        .grid-3 .card .table td {
            padding: 8px 4px;
        }

        .grid-3 .card .card-header h3 {
            font-size: 1.1rem;
        }

        .grid-3 .card .controls {
            gap: 8px;
        }

        .grid-3 .card .btn {
            padding: 8px 16px;
            font-size: 0.8rem;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            padding: 24px;
            box-shadow: var(--shadow-lg);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-xl);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--gray-200);
        }

        .card-header i {
            font-size: 1.5rem;
            margin-right: 12px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .card-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-800);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            border: none;
            border-radius: var(--border-radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            min-width: 120px;
            gap: 8px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color), #38a169);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger-color), #e53e3e);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--gray-500), var(--gray-600));
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn:disabled {
            background: var(--gray-300);
            color: var(--gray-500);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:disabled::before {
            display: none;
        }

        .status {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            gap: 8px;
        }

        .status-connected {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            color: var(--success-color);
            border: 1px solid #c3e6cb;
        }

        .status-disconnected {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            color: var(--danger-color);
            border: 1px solid #f5c6cb;
        }

        .status i {
            font-size: 0.875rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--gray-700);
        }

        .form-control {
            padding: 12px 16px;
            border: 2px solid var(--gray-200);
            border-radius: var(--border-radius-sm);
            font-size: 0.875rem;
            transition: var(--transition);
            background: white;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-control:disabled {
            background: var(--gray-100);
            color: var(--gray-500);
            cursor: not-allowed;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress {
            width: 100%;
            height: 12px;
            background: var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            width: 0%;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .log {
            background: var(--gray-900);
            color: var(--gray-100);
            border-radius: var(--border-radius-sm);
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Consolas', monospace;
            font-size: 0.8rem;
            line-height: 1.5;
            border: 1px solid var(--gray-700);
            position: relative;
        }

        .log::-webkit-scrollbar {
            width: 8px;
        }

        .log::-webkit-scrollbar-track {
            background: var(--gray-800);
            border-radius: 4px;
        }

        .log::-webkit-scrollbar-thumb {
            background: var(--gray-600);
            border-radius: 4px;
        }

        .log::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .status-group {
            background: var(--gray-50);
            padding: 20px;
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--gray-200);
        }

        .status-group h4 {
            margin: 0 0 16px 0;
            color: var(--gray-700);
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            font-size: 0.875rem;
        }

        .status-item strong {
            color: var(--gray-600);
            font-weight: 500;
        }

        .status-item span {
            color: var(--primary-color);
            font-weight: 600;
        }

        .file-upload {
            border: 2px dashed var(--gray-300);
            border-radius: var(--border-radius);
            padding: 40px 20px;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .file-upload:hover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.05);
        }

        .file-upload.dragover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.1);
        }

        .file-upload i {
            font-size: 3rem;
            color: var(--gray-400);
            margin-bottom: 16px;
        }

        .file-upload:hover i {
            color: var(--primary-color);
        }

        .file-info {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 16px;
            border-radius: var(--border-radius-sm);
            margin: 16px 0;
            border-left: 4px solid var(--info-color);
        }

        .temp-preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .preset-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: var(--border-radius-sm);
            padding: 16px 12px;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .preset-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .preset-card.heating-disabled {
            opacity: 0.6;
            pointer-events: none;
            background: var(--gray-50);
        }

        .preset-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--gray-600);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .temp-input {
            width: 100%;
            border: none;
            background: transparent;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-800);
            margin: 8px 0;
        }

        .temp-input:focus {
            outline: none;
        }

        .temp-unit {
            font-size: 0.75rem;
            color: var(--gray-500);
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--gray-300);
            transition: var(--transition);
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: var(--transition);
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
        }

        input:checked + .slider {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: var(--border-radius-sm);
            box-shadow: var(--shadow-lg);
            border-left: 4px solid var(--success-color);
            transform: translateX(100%);
            transition: var(--transition);
            z-index: 1000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .grid {
                grid-template-columns: 1fr;
            }
            
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            .card {
                padding: 20px 16px;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .temp-preset-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            

        }

        /* 加热状态的特殊样式 */
        .heating-active .preset-card {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-color: var(--warning-color);
        }

        .heating-active .preset-card::after {
            content: "🔥";
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.875rem;
        }

        /* LED选择器的特殊样式 */
        .led-selector {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }

        .led-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        /* 更好的响应式表格 */
        .responsive-table {
            overflow-x: auto;
            margin: 16px 0;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--gray-200);
        }

        .table th {
            background: var(--gray-50);
            font-weight: 600;
            color: var(--gray-700);
        }

        /* 添加更多动画效果 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--gray-300);
            transition: var(--transition);
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: var(--transition);
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
        }

        input:checked + .slider {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: var(--border-radius-sm);
            box-shadow: var(--shadow-lg);
            border-left: 4px solid var(--success-color);
            transform: translateX(100%);
            transition: var(--transition);
            z-index: 1000;
            min-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            border-left-color: var(--danger-color);
        }

        .notification.warning {
            border-left-color: var(--warning-color);
        }

        .notification.info {
            border-left-color: var(--info-color);
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .bounce {
            animation: bounce 0.6s ease-in-out;
        }

        @keyframes bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }

        /* 状态指示器 */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: var(--success-color);
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: var(--danger-color);
        }

        .status-indicator.connecting {
            background: var(--warning-color);
            animation: spin 1s linear infinite;
        }

        /* 优化文件拖拽样式 */
        .file-upload.dragover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        /* 优化进度条 */
        .progress-bar.pulse {
            animation: progressPulse 1.5s infinite;
        }

        @keyframes progressPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* 温度卡片悬停效果 */
        .preset-card:hover .temp-input {
            color: var(--primary-color);
        }

        /* LED预览样式 */
        .led-preview.clam { background: #f5f5f5; border-color: #ccc; }
        .led-preview.stealth { background: #2d3748; }
        .led-preview.purple { background: #805ad5; }
        .led-preview.blue { background: #3182ce; }
        .led-preview.cyan { background: #00b5d8; }
        .led-preview.green { background: #38a169; }
        .led-preview.yellow { background: #d69e2e; }
        .led-preview.orange { background: #dd6b20; }
        .led-preview.red { background: #e53e3e; }
        .led-preview.pink { background: #d53f8c; }
        .led-preview.cali-sunset { background: linear-gradient(45deg, #ff6b6b, #ffa500); }
        .led-preview.purple-haze { background: linear-gradient(45deg, #9f7aea, #b794f6); }
        .led-preview.northern-nights { background: linear-gradient(45deg, #2d3748, #4a5568); }
        .led-preview.vegas-nights { background: linear-gradient(45deg, #ed8936, #f6ad55); }
        .led-preview.blue-dream { background: linear-gradient(45deg, #3182ce, #63b3ed); }
        .led-preview.strawberry-cough { background: linear-gradient(45deg, #e53e3e, #fc8181); }
        .led-preview.florida-groves { background: linear-gradient(45deg, #38a169, #68d391); }
        .led-preview.lime-light { background: linear-gradient(45deg, #68d391, #9ae6b4); }

        /* 响应式优化 */
        @media (max-width: 1024px) {
            .status-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 640px) {
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .temp-preset-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* 工具提示 */
        .tooltip {
            position: relative;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--gray-800);
            color: white;
            padding: 8px 12px;
            border-radius: var(--border-radius-sm);
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: var(--transition);
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        /* 加载状态 */
        .loading {
            position: relative;
            pointer-events: none;
        }

        .loading::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid transparent;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1;
        }

        .loading * {
            opacity: 0.5;
        }

        /* Preset控件样式 */
        .preset-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--gray-200);
        }

        .preset-control-item {
            margin-bottom: 8px;
        }

        .preset-control-label {
            display: block;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--gray-600);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preset-control-input {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .preset-slider {
            flex: 1;
            height: 4px;
            background: var(--gray-200);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .preset-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .preset-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .preset-slider:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preset-value {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--primary-color);
            min-width: 28px;
            text-align: right;
        }

        .preset-mode-select {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid var(--gray-300);
            border-radius: 4px;
            font-size: 0.7rem;
            background: white;
            color: var(--gray-700);
            cursor: pointer;
            transition: var(--transition);
        }

        .preset-mode-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .preset-mode-select:disabled {
            background: var(--gray-100);
            color: var(--gray-500);
            cursor: not-allowed;
        }

        /* 加热状态下的禁用样式 */
        .preset-slider.heating-disabled,
        .preset-mode-select.heating-disabled {
            opacity: 0.6;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="grid grid-3">
            <!-- 蓝牙连接卡片 -->
            <div class="card fade-in">
                <div class="card-header">
                    <i class="fas fa-bluetooth"></i>
                    <h3>Bluetooth Connection</h3>
                </div>
                <div id="connectionStatus" class="status status-disconnected">
                    <span class="status-indicator disconnected" id="statusIndicator"></span>
                    <i class="fas fa-unlink" id="statusIcon"></i>
                    <span id="statusText">Device Not Connected</span>
                </div>
                <div class="controls">
                    <button id="connectBtn" class="btn btn-primary tooltip" onclick="connectDevice()" data-tooltip="Connect to PY32F071 Bluetooth device">
                        <i class="fas fa-link"></i>
                        Connect Device
                    </button>
                    <button id="disconnectBtn" class="btn btn-danger tooltip" onclick="disconnectDevice()" disabled data-tooltip="Disconnect from device">
                        <i class="fas fa-unlink"></i>
                        Disconnect
                    </button>

                </div>
            </div>

            <!-- 设备信息卡片 -->
            <div class="card fade-in" id="deviceInfoCard" style="display: none;">
                <div class="card-header">
                    <i class="fas fa-info-circle"></i>
                    <h3>Device Information</h3>
                </div>
                <div class="responsive-table">
                    <table class="table">
                        <tr>
                            <td><strong>Model Number:</strong></td>
                            <td><span id="modelNumber">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Serial Number:</strong></td>
                            <td><span id="serialNumber">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Hardware Version:</strong></td>
                            <td><span id="hardwareVersion">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Software Revision:</strong></td>
                            <td><span id="softwareRevision">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Manufacturer:</strong></td>
                            <td><span id="manufacturerName">--</span></td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- 使用统计信息卡片 -->
            <div class="card fade-in" id="deviceStatsCard" style="display: none;">
                <div class="card-header">
                    <i class="fas fa-chart-bar"></i>
                    <h3>Device Usage Statistics</h3>
                </div>
                <div class="responsive-table">
                    <table class="table">
                        <tr>
                            <td><strong>Favorite Temperature:</strong></td>
                            <td><span id="favoriteTemp">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Total Heating Cycles:</strong></td>
                            <td><span id="totalHeatingCycles">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Most Cycles in Day:</strong></td>
                            <td><span id="mostCyclesInDay">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Charge Cycles:</strong></td>
                            <td><span id="chargeCycles">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Profile:</strong></td>
                            <td><span id="profile">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Light Mode:</strong></td>
                            <td><span id="lightMode">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Device Resets:</strong></td>
                            <td><span id="deviceResets">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Favorite Heating Time:</strong></td>
                            <td><span id="favoriteHeatingTime">--</span></td>
                        </tr>
                        <tr>
                            <td><strong>Session Total Time:</strong></td>
                            <td><span id="sessionTotalTime">--</span></td>
                        </tr>
                    </table>
                </div>
                <div style="margin-top: 16px;">
                    <button class="btn btn-primary" onclick="requestDeviceStats()" id="refreshStatsBtn" disabled>
                        <i class="fas fa-sync-alt"></i>
                        Refresh Statistics
                    </button>
                </div>
            </div>

        </div>

        <!-- 设备状态监控 -->
        <div class="card fade-in">
            <div class="card-header">
                <i class="fas fa-chart-line"></i>
                <h3>Device Status Monitor</h3>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label class="toggle-switch">
                    <input type="checkbox" id="notifyToggle" onchange="toggleNotifications()">
                    <span class="slider"></span>
                </label>
                <span style="margin-left: 12px; font-weight: 500;">
                    Real-time Monitoring
                    <span id="notifyStatus" style="margin-left: 8px; font-size: 0.875rem; color: var(--gray-500);">Disabled</span>
                </span>
            </div>
            
            <div id="deviceStatusInfo" style="display: none;">
                <div class="status-grid">
                    <div class="status-group">
                        <h4><i class="fas fa-thermometer-half"></i> Temperature</h4>
                        <div class="status-item">
                            <strong>Preset:</strong> 
                            <button id="presetBtn" class="btn btn-primary" onclick="switchPreset()" disabled style="min-width: 60px; padding: 6px 12px;">--</button>
                        </div>
                        <div class="status-item">
                            <strong>Target:</strong>
                            <span id="tempSetting">--</span>
                        </div>
                        <div class="status-item">
                            <strong>Current:</strong> 
                            <span id="realTemp">--</span>
                        </div>
                        <div class="status-item">
                            <strong>Preset Mode:</strong>
                            <span id="currentPresetMode" style="color: var(--primary-color); font-weight: 600;">Steady</span>
                        </div>
                    </div>
                    
                    <div class="status-group">
                        <h4><i class="fas fa-battery-half"></i> Power</h4>
                        <div class="status-item">
                            <strong>Battery:</strong>
                            <span id="batteryLevel">--</span>
                        </div>
                        <div class="status-item">
                            <strong>Charge State:</strong> 
                            <span id="chargeState">--</span>
                        </div>
                        <div class="status-item">
                            <strong>Brightness:</strong>
                            <input type="range" id="brightness" min="0" max="100" value="25" 
                                   style="width: 80px;" 
                                   oninput="updateBrightnessDisplay(this.value)" 
                                   onchange="setBrightness(this.value); endSliderDrag('brightness')"
                                   onmousedown="startSliderDrag('brightness')"
                                   ontouchstart="startSliderDrag('brightness')" 
                                   disabled>
                            <span id="brightnessDisplay" style="font-size: 0.8rem; margin-left: 8px;">25</span>
                        </div>
                    </div>
                    
                    <div class="status-group">
                        <h4><i class="fas fa-fire"></i> Session</h4>
                        <div style="margin-bottom: 16px; text-align: center;">
                            <button id="sessionControlBtn" class="btn btn-success" onclick="toggleSession()" disabled style="min-width: 150px;">
                                <i class="fas fa-play"></i>
                                Press to Heat
                            </button>
                        </div>
                        <div style="margin-bottom: 16px; text-align: center;">
                            <button id="cleaningAssistBtn" class="btn btn-secondary" onclick="toggleCleaningAssist()" disabled style="min-width: 150px;">
                                <i class="fas fa-broom"></i>
                                Cleaning Assist
                            </button>
                        </div>
                        <div class="status-item">
                            <strong>Auto Shut:</strong>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="range" id="autoShutTime" min="0" max="30" value="2" 
                                       style="width: 80px;" 
                                       oninput="updateAutoShutDisplay(this.value)" 
                                       onchange="setAutoShutTime(this.value); endSliderDrag('autoShutTime')"
                                       onmousedown="startSliderDrag('autoShutTime')"
                                       ontouchstart="startSliderDrag('autoShutTime')" 
                                       disabled>
                                <span id="autoShutDisplay" style="font-size: 0.8rem; margin-left: 8px;">2 min</span>
                            </div>
                        </div>

                        <div class="status-item">
                            <strong>Countdown:</strong> 
                            <span id="remainTime">--</span>s
                        </div>
                        <div class="status-item">
                            <strong>Session Time:</strong> 
                            <span id="sessionRemainTime">--</span>s
                        </div>
                    </div>
                    
                    <div class="status-group">
                        <h4><i class="fas fa-cog"></i> Settings</h4>
                        <div class="status-item">
                            <strong>LED Mode:</strong>
                            <div class="led-selector">
                                <select id="ledPresetSelect" class="form-control" onchange="setLedPreset(this.value)" style="font-size: 0.8rem;">
                                    <option value="0x00">Clam</option>
                                    <option value="0x01">Stealth</option>
                                    <option value="0x02">Purple</option>
                                    <option value="0x03">Blue</option>
                                    <option value="0x04">Cyan</option>
                                    <option value="0x05">Green</option>
                                    <option value="0x06">Yellow</option>
                                    <option value="0x07">Orange</option>
                                    <option value="0x08">Red</option>
                                    <option value="0x09">Pink</option>
                                    <option value="0x0A">Cali Sunset</option>
                                    <option value="0x0B">Purple Haze</option>
                                    <option value="0x0C">Northern Nights</option>
                                    <option value="0x0D">Vegas Nights</option>
                                    <option value="0x0E">Blue Dream</option>
                                    <option value="0x0F">Strawberry Cough</option>
                                    <option value="0x10">Florida Groves</option>
                                    <option value="0x11">Lime Light</option>
                                </select>
                                <div class="led-preview" id="ledPreview"></div>
                            </div>
                        </div>
                        <div class="status-item">
                            <strong>Current:</strong> 
                            <span id="ledPreset">--</span>
                        </div>
                        <div class="status-item">
                            <strong>Haptic:</strong> 
                            <button id="hapticBtn" class="btn btn-success" onclick="toggleHaptic()" disabled style="min-width: 80px; padding: 6px 12px; font-size: 0.8rem;">
                                On
                            </button>
                        </div>
                        <div class="status-item">
                            <strong>Boost:</strong> 
                            <button id="boostBtn" class="btn btn-secondary tooltip" onclick="toggleBoost()" disabled 
                                    style="min-width: 80px; padding: 6px 12px; font-size: 0.8rem;"
                                    data-tooltip="Click to send incremental boost value (+1 each click)">
                                Boost
                            </button>
                        </div>
                        <div class="status-item">
                            <strong>Firmware:</strong> 
                            <button id="updateFirmwareBtn" class="btn btn-warning tooltip" onclick="startFirmwareUpdate()" disabled 
                                    style="min-width: 150px; padding: 6px 12px; font-size: 0.8rem;"
                                    data-tooltip="Update device firmware using simple_ota.bin">
                                <i class="fas fa-download"></i>
                                Update Firmware
                            </button>
                        </div>
                        <div class="status-item" id="firmwareStatusContainer" style="display: none;">
                            <strong>Status:</strong>
                            <span id="firmwareStatusText" style="font-size: 0.8rem; font-weight: 600;"></span>
                        </div>
                        <div class="status-item" id="otaProgressContainer" style="display: none;">
                            <strong>OTA Progress:</strong>
                            <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                                <div class="progress" style="flex: 1; height: 8px;">
                                    <div class="progress-bar" id="otaProgressBar" style="width: 0%;"></div>
                                </div>
                                <span id="otaProgressText" style="font-size: 0.8rem; color: var(--primary-color);">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Mode Control -->
                    <div class="status-group" style="margin-bottom: 20px;">
                        <h4><i class="fas fa-arrows-alt-v"></i> Mode Control</h4>
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
                            <div>
                                <strong>Current Mode:</strong>
                                <span id="currentModeDisplay" style="margin-left: 8px;">Steady</span>
                            </div>
                            <button id="modeControlBtn" class="btn btn-primary" onclick="switchMode()" disabled style="min-width: 120px;">
                                <i class="fas fa-sync-alt"></i>
                                Switch Mode
                            </button>
                        </div>
                        <div style="margin-top: 8px; text-align: center; font-size: 0.8rem; color: var(--gray-500);">
                            <span id="modeSequence">Steady → Ascent → Descent → Valley → Hill</span>
                        </div>
                        <div class="status-item" style="margin-top: 12px;">
                            <strong>Hold Time:</strong>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="range" id="holdTime" min="10" max="90" value="30" 
                                       style="width: 80px;" 
                                       oninput="updateHoldTimeDisplay(this.value)" 
                                       onchange="setHoldTime(this.value); endSliderDrag('holdTime')"
                                       onmousedown="startSliderDrag('holdTime')"
                                       ontouchstart="startSliderDrag('holdTime')" 
                                       disabled>
                                <span id="holdTimeDisplay" style="font-size: 0.8rem; margin-left: 8px;">30 sec</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 实时温度图表 - 独立的全宽区域 -->
        <div class="grid">
            <div class="card fade-in">
                <div class="card-header">
                    <i class="fas fa-chart-line"></i>
                    <h3>Real-time Temperature Chart</h3>
                    <button id="clearChartBtn" class="btn btn-secondary" onclick="clearTemperatureChart()" 
                            style="margin-left: auto; padding: 6px 12px; font-size: 0.8rem;">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
                <div style="position: relative; height: 300px; width: 100%; padding: 16px;">
                    <canvas id="temperatureChart"></canvas>
                </div>
                <div style="text-align: center; font-size: 0.8rem; color: var(--gray-500); padding-bottom: 16px;">
                    <span id="chartInfo">Real-time temperature monitoring</span>
                </div>
            </div>
        </div>

        <!-- 温度预设 -->
        <div class="grid">
            <div class="card fade-in">
                <div class="card-header">
                    <i class="fas fa-sliders-h"></i>
                    <h3>Temperature Presets (250-650°F)</h3>
                </div>
                <div class="temp-preset-grid" id="tempPresets">
                    <div class="preset-card">
                        <div class="preset-title">Preset 1</div>
                        <input type="number" id="tempF1" min="250" max="650" value="450" 
                               class="temp-input" onchange="setTemperature(1, this.value)">
                        <div class="temp-unit">°F</div>
                        <div class="preset-controls">
                            <div class="preset-control-item">
                                <label class="preset-control-label">Hold Time:</label>
                                <div class="preset-control-input">
                                    <input type="range" id="presetHoldTime1" min="10" max="90" value="30" 
                                           class="preset-slider" 
                                           oninput="updatePresetHoldTimeDisplay(1, this.value)" 
                                           onchange="setPresetHoldTime(1, this.value); endSliderDrag('presetHoldTime1')"
                                           onmousedown="startSliderDrag('presetHoldTime1')"
                                           ontouchstart="startSliderDrag('presetHoldTime1')" 
                                           disabled>
                                    <span id="presetHoldTimeDisplay1" class="preset-value">30s</span>
                                </div>
                            </div>
                            <div class="preset-control-item">
                                <label class="preset-control-label">Mode:</label>
                                <select id="presetMode1" class="preset-mode-select" onchange="setPresetMode(1, this.value)" disabled>
                                    <option value="0xA1">Steady</option>
                                    <option value="0xB1">Ascent</option>
                                    <option value="0xC1">Descent</option>
                                    <option value="0xD1">Valley</option>
                                    <option value="0xE1">Hill</option>
                                    <option value="0xF1">Custom</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="preset-card">
                        <div class="preset-title">Preset 2</div>
                        <input type="number" id="tempF2" min="250" max="650" value="500" 
                               class="temp-input" onchange="setTemperature(2, this.value)">
                        <div class="temp-unit">°F</div>
                        <div class="preset-controls">
                            <div class="preset-control-item">
                                <label class="preset-control-label">Hold Time:</label>
                                <div class="preset-control-input">
                                    <input type="range" id="presetHoldTime2" min="10" max="90" value="30" 
                                           class="preset-slider" 
                                           oninput="updatePresetHoldTimeDisplay(2, this.value)" 
                                           onchange="setPresetHoldTime(2, this.value); endSliderDrag('presetHoldTime2')"
                                           onmousedown="startSliderDrag('presetHoldTime2')"
                                           ontouchstart="startSliderDrag('presetHoldTime2')" 
                                           disabled>
                                    <span id="presetHoldTimeDisplay2" class="preset-value">30s</span>
                                </div>
                            </div>
                            <div class="preset-control-item">
                                <label class="preset-control-label">Mode:</label>
                                <select id="presetMode2" class="preset-mode-select" onchange="setPresetMode(2, this.value)" disabled>
                                    <option value="0xA1">Steady</option>
                                    <option value="0xB1">Ascent</option>
                                    <option value="0xC1">Descent</option>
                                    <option value="0xD1">Valley</option>
                                    <option value="0xE1">Hill</option>
                                    <option value="0xF1">Custom</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="preset-card">
                        <div class="preset-title">Preset 3</div>
                        <input type="number" id="tempF3" min="250" max="650" value="550" 
                               class="temp-input" onchange="setTemperature(3, this.value)">
                        <div class="temp-unit">°F</div>
                        <div class="preset-controls">
                            <div class="preset-control-item">
                                <label class="preset-control-label">Hold Time:</label>
                                <div class="preset-control-input">
                                    <input type="range" id="presetHoldTime3" min="10" max="90" value="30" 
                                           class="preset-slider" 
                                           oninput="updatePresetHoldTimeDisplay(3, this.value)" 
                                           onchange="setPresetHoldTime(3, this.value); endSliderDrag('presetHoldTime3')"
                                           onmousedown="startSliderDrag('presetHoldTime3')"
                                           ontouchstart="startSliderDrag('presetHoldTime3')" 
                                           disabled>
                                    <span id="presetHoldTimeDisplay3" class="preset-value">30s</span>
                                </div>
                            </div>
                            <div class="preset-control-item">
                                <label class="preset-control-label">Mode:</label>
                                <select id="presetMode3" class="preset-mode-select" onchange="setPresetMode(3, this.value)" disabled>
                                    <option value="0xA1">Steady</option>
                                    <option value="0xB1">Ascent</option>
                                    <option value="0xC1">Descent</option>
                                    <option value="0xD1">Valley</option>
                                    <option value="0xE1">Hill</option>
                                    <option value="0xF1">Custom</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="preset-card">
                        <div class="preset-title">Preset 4</div>
                        <input type="number" id="tempF4" min="250" max="650" value="600" 
                               class="temp-input" onchange="setTemperature(4, this.value)">
                        <div class="temp-unit">°F</div>
                        <div class="preset-controls">
                            <div class="preset-control-item">
                                <label class="preset-control-label">Hold Time:</label>
                                <div class="preset-control-input">
                                    <input type="range" id="presetHoldTime4" min="10" max="90" value="30" 
                                           class="preset-slider" 
                                           oninput="updatePresetHoldTimeDisplay(4, this.value)" 
                                           onchange="setPresetHoldTime(4, this.value); endSliderDrag('presetHoldTime4')"
                                           onmousedown="startSliderDrag('presetHoldTime4')"
                                           ontouchstart="startSliderDrag('presetHoldTime4')" 
                                           disabled>
                                    <span id="presetHoldTimeDisplay4" class="preset-value">30s</span>
                                </div>
                            </div>
                            <div class="preset-control-item">
                                <label class="preset-control-label">Mode:</label>
                                <select id="presetMode4" class="preset-mode-select" onchange="setPresetMode(4, this.value)" disabled>
                                    <option value="0xA1">Steady</option>
                                    <option value="0xB1">Ascent</option>
                                    <option value="0xC1">Descent</option>
                                    <option value="0xD1">Valley</option>
                                    <option value="0xE1">Hill</option>
                                    <option value="0xF1">Custom</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="preset-card">
                        <div class="preset-title">Preset 5</div>
                        <input type="number" id="tempF5" min="250" max="650" value="613" 
                               class="temp-input" onchange="setTemperature(5, this.value)">
                        <div class="temp-unit">°F</div>
                        <div class="preset-controls">
                            <div class="preset-control-item">
                                <label class="preset-control-label">Hold Time:</label>
                                <div class="preset-control-input">
                                    <input type="range" id="presetHoldTime5" min="10" max="90" value="30" 
                                           class="preset-slider" 
                                           oninput="updatePresetHoldTimeDisplay(5, this.value)" 
                                           onchange="setPresetHoldTime(5, this.value); endSliderDrag('presetHoldTime5')"
                                           onmousedown="startSliderDrag('presetHoldTime5')"
                                           ontouchstart="startSliderDrag('presetHoldTime5')" 
                                           disabled>
                                    <span id="presetHoldTimeDisplay5" class="preset-value">30s</span>
                                </div>
                            </div>
                            <div class="preset-control-item">
                                <label class="preset-control-label">Mode:</label>
                                <select id="presetMode5" class="preset-mode-select" onchange="setPresetMode(5, this.value)" disabled>
                                    <option value="0xA1">Steady</option>
                                    <option value="0xB1">Ascent</option>
                                    <option value="0xC1">Descent</option>
                                    <option value="0xD1">Valley</option>
                                    <option value="0xE1">Hill</option>
                                    <option value="0xF1">Custom</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Custom setting -->
        <div class="grid">
            <div class="card fade-in" id="customConfigCard">
                <div class="card-header">
                    <i class="fas fa-cogs"></i>
                    <h3>Custom setting</h3>
                </div>
                <div style="padding: 16px;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                        <template id="customConfigRowTemplate">
                            <div class="custom-config-row">
                                <label>point<span class="custom-index"></span>：</label>
                                <input type="number" class="custom-temp" min="0" max="65535" step="1" style="width: 70px;" placeholder="温度">
                                <span>°</span>
                                <input type="number" class="custom-time" min="0" max="255" step="1" style="width: 50px;" placeholder="时间">
                                <span>s</span>
                            </div>
                        </template>
                        <!-- 8组输入框 -->
                        <div class="custom-config-row">
                            <label>point1：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="400" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="0" step="1" value="0" style="width: 50px;" readonly>
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point2：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="410" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="1" max="255" step="1" value="30" style="width: 50px;" onchange="validateCustomTime(this, 2)" oninput="validateCustomTime(this, 2)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point3：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="420" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="60" style="width: 50px;" onchange="validateCustomTime(this, 3)" oninput="validateCustomTime(this, 3)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point4：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="430" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="90" style="width: 50px;" onchange="validateCustomTime(this, 4)" oninput="validateCustomTime(this, 4)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point5：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="440" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="120" style="width: 50px;" onchange="validateCustomTime(this, 5)" oninput="validateCustomTime(this, 5)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point6：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="450" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="150" style="width: 50px;" onchange="validateCustomTime(this, 6)" oninput="validateCustomTime(this, 6)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point7：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="460" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="180" style="width: 50px;" onchange="validateCustomTime(this, 7)" oninput="validateCustomTime(this, 7)">
                            <span>s</span>
                        </div>
                        <div class="custom-config-row">
                            <label>point8：</label>
                            <input type="number" class="custom-temp" min="0" max="65535" step="1" value="470" style="width: 70px;">
                            <span>°</span>
                            <input type="number" class="custom-time" min="0" max="255" step="1" value="210" style="width: 50px;" onchange="validateCustomTime(this, 8)" oninput="validateCustomTime(this, 8)">
                            <span>s</span>
                        </div>
                    </div>
                    <div style="margin-top: 18px; text-align: right;">
                        <button class="btn btn-primary" id="sendCustomProfileBtn" style="min-width: 180px;">send custom</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Raw Data -->
        <div class="grid">
            <div class="card fade-in">
                <div class="card-header">
                    <i class="fas fa-code"></i>
                    <h3>Raw Data</h3>
                </div>
                <div class="responsive-table">
                    <table class="table">
                        <tr>
                            <td><strong>Last Packet:</strong></td>
                            <td><span id="rawData" style="font-family: monospace; font-size: 0.8rem;">No data</span></td>
                        </tr>
                        <tr>
                            <td><strong>Packet Count:</strong></td>
                            <td><span id="packetCount">0</span></td>
                        </tr>
                        <tr>
                            <td><strong>Last Updated:</strong></td>
                            <td><span id="lastUpdate">Never</span></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        </div>

        <!-- 系统日志 -->
        <div class="grid">
            <div class="card fade-in">
                <div class="card-header">
                    <i class="fas fa-terminal"></i>
                    <h3>System Log</h3>
                    <button class="btn btn-secondary" onclick="clearLog()" style="margin-left: auto; padding: 6px 12px; font-size: 0.8rem;">
                        <i class="fas fa-trash"></i>
                        Clear
                    </button>
                </div>
                <div id="logOutput" class="log"></div>
            </div>
        </div>
    </div>

    <!-- 通知组件 -->
    <div id="notification" class="notification">
        <div style="display: flex; align-items: center; gap: 12px;">
            <i class="fas fa-check-circle" style="color: var(--success-color);"></i>
            <span id="notificationText">Operation completed successfully!</span>
        </div>
    </div>

    <script>
        let bluetoothDevice;
        let characteristic;

        // Notify监听相关变量
        let rxCharacteristic = null;
        let notificationsEnabled = false;
        let notifyPacketCount = 0;
        let globalPresetIndex = 0;
        let globalTempF = [0,0,0,0,0,0];
        let globalTempC = [0,0,0,0,0,0];
        let currentPreset = 1; // 当前预设值 (1-5)
        let holdTime = 30;
        let cleaningAssistEnabled = false; // 清洁助手状态
        
        // 每个preset独立的Hold Time和Mode存储 (preset 1-5)
        let presetHoldTimes = [0, 30, 30, 30, 30, 30]; // index 0 未使用，1-5对应preset 1-5
        let presetModes = [0, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1]; // index 0 未使用，1-5对应preset 1-5，默认Steady模式
        
        // 当前设备状态跟踪 - B9命令的所有字节状态
        let currentB9State = {
            byte3: 0x01,   // 预设值 (1-5)
            byte6: 0x00,   // LED值
            byte8: 0x02,   // Auto Shut Time (0-30分钟)
            byte10: 0x00,  // Session状态
            byte11: 0xAA,  // Haptic Feedback (0xAA=On, 0x00=Off)
            byte12: 0x00,  // Session Boost (0xAA=Enabled, 0x00=Disabled)
            byte13: 25,    // Brightness (0-100)
            // 后续可以继续添加更多字节：byte14, byte15, byte16 等等
        };

        // 模式映射
        const MODE_TYPES = {
            0xA1: 'Steady',
            0xB1: 'Ascent', 
            0xC1: 'Descent',
            0xD1: 'Valley',
            0xE1: 'Hill',
            0xF1: 'Custom'
        };

        let currentMode = 0xA1; // 默认模式为 Steady
        
        // 滑块拖动状态跟踪
        let isDraggingSlider = false;
        let sliderTimeouts = {}; // 存储不同滑块的超时ID
        let draggingSliders = new Set(); // 跟踪正在拖动的滑块

        // 温度图表相关变量
        let temperatureChart = null;
        let temperatureData = [];
        let chartStartTime = Date.now();
        const MAX_DATA_POINTS = 300; // 最大数据点数量（5分钟 * 60秒）
        let lastTemperatureUpdate = 0;

        // OTA相关变量
        let otaWriteQueue = [];
        let otaCrc16Array = [];
        let otaChunkCounter = 0;
        let otaInProgress = false;
        const OTA_CHUNK_SIZE = 16;
        const OTA_BLOCK_SIZE = 2048;
        const OTA_CHUNKS_BEFORE_NOTIFY = 128;

        // LED颜色映射
        const LED_COLORS = {
            0x00: 'Clam',
            0x01: 'Stealth',
            0x02: 'Purple',
            0x03: 'Blue',
            0x04: 'Cyan',
            0x05: 'Green',
            0x06: 'Yellow',
            0x07: 'Orange',
            0x08: 'Red',
            0x09: 'Pink',
            0x0A: 'Cali Sunset',
            0x0B: 'Purple Haze',
            0x0C: 'Northern Nights',
            0x0D: 'Vegas Nights',
            0x0E: 'Blue Dream',
            0x0F: 'Strawberry Cough',
            0x10: 'Florida Groves',
            0x11: 'Lime Light'
        };



        // 服务和特征UUID（请根据实际情况修改）
        const SERVICE_UUID = '0000fee7-0000-1000-8000-00805f9b34fb';
        const TX_CHARACTERISTIC_UUID = '0000fec1-0000-1000-8000-00805f9b34fb';
        const RX_CHARACTERISTIC_UUID = '0000fec2-0000-1000-8000-00805f9b34fb';
        
        // 设备信息服务UUID
        const DEVICE_INFO_SERVICE_UUID = '0000180a-0000-1000-8000-00805f9b34fb';
        const MODEL_NUMBER_UUID = '00002a24-0000-1000-8000-00805f9b34fb';
        const SERIAL_NUMBER_UUID = '00002a25-0000-1000-8000-00805f9b34fb';
        const HARDWARE_VERSION_UUID = '00002a27-0000-1000-8000-00805f9b34fb';
        const SOFTWARE_REVISION_UUID = '00002a28-0000-1000-8000-00805f9b34fb';
        const MANUFACTURER_NAME_UUID = '00002a29-0000-1000-8000-00805f9b34fb';

        function log(message) {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            logOutput.textContent += `[${timestamp}] ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logOutput').textContent = '';
        }

        // 初始化温度图表
        function initTemperatureChart() {
            const ctx = document.getElementById('temperatureChart').getContext('2d');
            temperatureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperature (°F)',
                        data: [],
                        borderColor: 'rgb(102, 126, 234)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 1,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                maxTicksLimit: 6,
                                font: {
                                    size: 10
                                }
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                font: {
                                    size: 10
                                }
                            },
                            min: 0,
                            max: 650 // 固定最大值为650°F
                        }
                    },
                    animation: {
                        duration: 0 // 禁用动画以提高性能
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }

        // 更新图表信息显示（Y轴最大值已固定为650°F）
        function updateChartInfo() {
            const chartInfo = document.getElementById('chartInfo');
            if (chartInfo && temperatureData.length > 0) {
                const pointCount = temperatureData.length;
                const duration = Math.floor(pointCount / 60);
                chartInfo.textContent = `${pointCount} points, ~${duration}min data (Max: 650°F)`;
            }
        }

        // 添加温度数据点到图表
        function addTemperaturePoint(temperature) {
            const now = Date.now();
            
            // 避免过于频繁的更新（限制为每500ms更新一次）
            if (now - lastTemperatureUpdate < 500) {
                return;
            }
            lastTemperatureUpdate = now;
            
            const timeFromStart = Math.floor((now - chartStartTime) / 1000); // 秒
            const timeLabel = formatTimeLabel(timeFromStart);
            
            // 添加新数据点
            temperatureData.push({
                time: timeFromStart,
                temperature: temperature
            });
            
            // 限制数据点数量
            if (temperatureData.length > MAX_DATA_POINTS) {
                temperatureData.shift();
                // 重新计算时间标签
                chartStartTime = now - (MAX_DATA_POINTS * 1000);
            }
            
            // 更新图表信息显示
            updateChartInfo();
            
            // 更新图表
            if (temperatureChart) {
                temperatureChart.data.labels = temperatureData.map(point => formatTimeLabel(point.time));
                temperatureChart.data.datasets[0].data = temperatureData.map(point => point.temperature);
                temperatureChart.update('none'); // 使用'none'模式避免动画
            }
            
            // 更新图表信息
            updateChartInfo();
        }

        // 格式化时间标签
        function formatTimeLabel(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            if (minutes > 0) {
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                return `${remainingSeconds}s`;
            }
        }

        // 清除图表数据
        function clearTemperatureChart() {
            temperatureData = [];
            chartStartTime = Date.now();
            lastTemperatureUpdate = 0;
            
            if (temperatureChart) {
                temperatureChart.data.labels = [];
                temperatureChart.data.datasets[0].data = [];
                temperatureChart.update();
            }
            
            const chartInfo = document.getElementById('chartInfo');
            if (chartInfo) {
                chartInfo.textContent = 'Real-time temperature monitoring';
            }
            
            log('Temperature chart data cleared');
            showNotification('图表数据已清除', 'info', 2000);
        }

        // 现代化通知系统
        function showNotification(message, type = 'success', duration = 3000) {
            const notification = document.getElementById('notification');
            const icon = notification.querySelector('i');
            const text = document.getElementById('notificationText');
            
            // 重置类名
            notification.className = 'notification';
            
            // 设置图标和样式
            switch(type) {
                case 'success':
                    icon.className = 'fas fa-check-circle';
                    notification.classList.add('show');
                    break;
                case 'error':
                    icon.className = 'fas fa-exclamation-circle';
                    notification.classList.add('show', 'error');
                    break;
                case 'warning':
                    icon.className = 'fas fa-exclamation-triangle';
                    notification.classList.add('show', 'warning');
                    break;
                case 'info':
                    icon.className = 'fas fa-info-circle';
                    notification.classList.add('show', 'info');
                    break;
            }
            
            text.textContent = message;
            
            // 自动隐藏
            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }

        // 添加连接状态动画
        function updateConnectionStatusWithAnimation(connected, connecting = false) {
            const statusElement = document.getElementById('connectionStatus');
            const indicator = document.getElementById('statusIndicator');
            const icon = document.getElementById('statusIcon');
            const text = document.getElementById('statusText');
            
            // 获取控制按钮
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connecting) {
                statusElement.className = 'status status-disconnected';
                indicator.className = 'status-indicator connecting';
                icon.className = 'fas fa-spinner spinning';
                text.textContent = 'Connecting...';
                return;
            }
            
            if (connected) {
                statusElement.className = 'status status-connected bounce';
                indicator.className = 'status-indicator connected';
                icon.className = 'fas fa-link';
                text.textContent = 'Device Connected';
                
                // 启用连接状态的按钮
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                
                // 启用设备控制相关的控件
                const sessionControlBtn = document.getElementById('sessionControlBtn');
                const presetBtn = document.getElementById('presetBtn');
                const autoShutTimeInput = document.getElementById('autoShutTime');
                const holdTimeInput = document.getElementById('holdTime');
                const brightnessInput = document.getElementById('brightness');
                const ledPresetSelect = document.getElementById('ledPresetSelect');
                const modeControlBtn = document.getElementById('modeControlBtn');
                const hapticBtn = document.getElementById('hapticBtn');
                const boostBtn = document.getElementById('boostBtn');
                const cleaningAssistBtn = document.getElementById('cleaningAssistBtn');
                const updateFirmwareBtn = document.getElementById('updateFirmwareBtn');
                
                if (sessionControlBtn) sessionControlBtn.disabled = false;
                if (presetBtn) presetBtn.disabled = false;
                if (autoShutTimeInput) autoShutTimeInput.disabled = false;
                if (holdTimeInput) holdTimeInput.disabled = false;
                if (brightnessInput) brightnessInput.disabled = false;
                if (ledPresetSelect) ledPresetSelect.disabled = false;
                if (modeControlBtn) modeControlBtn.disabled = false;
                if (hapticBtn) hapticBtn.disabled = false;
                if (cleaningAssistBtn) cleaningAssistBtn.disabled = false;
                if (updateFirmwareBtn) updateFirmwareBtn.disabled = false;
                // Boost按钮初始状态为禁用（只有加热时才启用）
                if (boostBtn) boostBtn.disabled = true;
                
                // 启用温度预设输入框
                ['tempF1', 'tempF2', 'tempF3', 'tempF4', 'tempF5'].forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.disabled = false;
                        input.classList.remove('heating-disabled');
                        // 为父容器也移除禁用类
                        const container = input.closest('.preset-card');
                        if (container) container.classList.remove('heating-disabled');
                    }
                });
                
                // 启用preset控件（Hold Time滑块和Mode选择器）
                for (let i = 1; i <= 5; i++) {
                    const holdTimeSlider = document.getElementById(`presetHoldTime${i}`);
                    const modeSelect = document.getElementById(`presetMode${i}`);
                    if (holdTimeSlider) holdTimeSlider.disabled = false;
                    if (modeSelect) modeSelect.disabled = false;
                }
                
                showNotification('设备连接成功！', 'success');
                
                // 显示设备信息卡片和统计信息卡片
                document.getElementById('deviceInfoCard').style.display = 'block';
                document.getElementById('deviceStatsCard').style.display = 'block';
                
                // 启用统计信息刷新按钮
                document.getElementById('refreshStatsBtn').disabled = false;
            } else {
                statusElement.className = 'status status-disconnected';
                indicator.className = 'status-indicator disconnected';
                icon.className = 'fas fa-unlink';
                text.textContent = 'Device Not Connected';
                
                // 禁用连接状态的按钮
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                
                // 禁用设备控制相关的控件
                const sessionControlBtn = document.getElementById('sessionControlBtn');
                const presetBtn = document.getElementById('presetBtn');
                const autoShutTimeInput = document.getElementById('autoShutTime');
                const holdTimeInput = document.getElementById('holdTime');
                const brightnessInput = document.getElementById('brightness');
                const ledPresetSelect = document.getElementById('ledPresetSelect');
                const modeControlBtn = document.getElementById('modeControlBtn');
                const hapticBtn = document.getElementById('hapticBtn');
                const boostBtn = document.getElementById('boostBtn');
                const cleaningAssistBtn = document.getElementById('cleaningAssistBtn');
                const updateFirmwareBtn = document.getElementById('updateFirmwareBtn');
                
                if (sessionControlBtn) sessionControlBtn.disabled = true;
                if (presetBtn) presetBtn.disabled = true;
                if (updateFirmwareBtn) updateFirmwareBtn.disabled = true;
                if (autoShutTimeInput) {
                    autoShutTimeInput.disabled = true;
                    autoShutTimeInput.value = 2;
                    updateAutoShutDisplay(2);
                }
                if (holdTimeInput) {
                    holdTimeInput.disabled = true;
                    holdTimeInput.value = 30;
                    updateHoldTimeDisplay(30);
                }
                if (brightnessInput) {
                    brightnessInput.disabled = true;
                    brightnessInput.value = 25;
                    updateBrightnessDisplay(25);
                }
                if (ledPresetSelect) ledPresetSelect.disabled = true;
                if (modeControlBtn) modeControlBtn.disabled = true;
                if (hapticBtn) {
                    hapticBtn.disabled = true;
                    updateHapticButton(true); // 重置为默认状态
                }
                if (boostBtn) {
                    boostBtn.disabled = true;
                    updateBoostButton(0); // 重置为默认状态
                }
                if (cleaningAssistBtn) {
                    cleaningAssistBtn.disabled = true;
                    updateCleaningAssistButton(false); // 重置为默认状态
                }
                
                // 禁用温度预设输入框
                ['tempF1', 'tempF2', 'tempF3', 'tempF4', 'tempF5'].forEach(id => {
                    const input = document.getElementById(id);
                    if (input) {
                        input.disabled = true;
                        // 重置值
                        const presetValues = [450, 500, 550, 600, 613];
                        const presetIndex = parseInt(id.replace('tempF', '')) - 1;
                        if (presetIndex >= 0 && presetIndex < presetValues.length) {
                            input.value = presetValues[presetIndex];
                        }
                    }
                });
                
                // 禁用preset控件（Hold Time滑块和Mode选择器）并重置值
                for (let i = 1; i <= 5; i++) {
                    const holdTimeSlider = document.getElementById(`presetHoldTime${i}`);
                    const modeSelect = document.getElementById(`presetMode${i}`);
                    if (holdTimeSlider) {
                        holdTimeSlider.disabled = true;
                        holdTimeSlider.value = 30;
                        updatePresetHoldTimeDisplay(i, 30);
                        presetHoldTimes[i] = 30; // 重置本地存储
                    }
                    if (modeSelect) {
                        modeSelect.disabled = true;
                        modeSelect.value = '0xA1'; // 重置为Steady模式
                        presetModes[i] = 0xA1; // 重置本地存储
                    }
                }
                
                // 重置notify状态
                notificationsEnabled = false;
                const notifyToggle = document.getElementById('notifyToggle');
                if (notifyToggle) {
                    notifyToggle.checked = false;
                }
                document.getElementById('notifyStatus').textContent = 'Disabled';
                document.getElementById('deviceStatusInfo').style.display = 'none';
                
                // 隐藏设备信息卡片和统计信息卡片并重置信息
                document.getElementById('deviceInfoCard').style.display = 'none';
                document.getElementById('deviceStatsCard').style.display = 'none';
                resetDeviceInfo();
                resetDeviceStats();
                
                // 禁用统计信息刷新按钮
                document.getElementById('refreshStatsBtn').disabled = true;
                
                // 清除温度图表数据
                if (temperatureChart) {
                    clearTemperatureChart();
                }
            }
            
            // 移除动画类
            setTimeout(() => {
                statusElement.classList.remove('bounce');
            }, 600);
        }



        // 添加按钮加载状态
        function setButtonLoading(buttonId, loading = true) {
            const button = document.getElementById(buttonId);
            if (loading) {
                button.classList.add('loading');
                button.disabled = true;
            } else {
                button.classList.remove('loading');
            }
        }



        // LED颜色预览功能
        function updateLedPreview(colorValue) {
            const preview = document.getElementById('ledPreview');
            const colorName = LED_COLORS[colorValue] || 'unknown';
            
            // 移除所有颜色类
            preview.className = 'led-preview';
            
            // 添加对应的颜色类
            const colorClass = colorName.toLowerCase().replace(/\s+/g, '-');
            preview.classList.add(colorClass);
        }

        // 新增：全局变量缓存C1~C4包内容
        let deviceInfoPackets = {
            c1: null,
            c2: null,
            c3: null,
            c4: null
        };

        function clearDeviceInfoPackets() {
            deviceInfoPackets = { c1: null, c2: null, c3: null, c4: null };
        }

        // 新增：解析C1~C4包并更新UI
        function handleDeviceInfoPacket(data) {
            if (data[0] === 0xC1) {
                deviceInfoPackets.c1 = data.slice(2, 19); // 17字节
            } else if (data[0] === 0xC2) {
                deviceInfoPackets.c2 = data.slice(2, 14); // 12字节
            } else if (data[0] === 0xC3) {
                deviceInfoPackets.c3 = data.slice(2, 10); // 8字节
            } else if (data[0] === 0xC4) {
                deviceInfoPackets.c4 = data.slice(2, 10); // 8字节
            }
            // 检查是否全部收到
            if (deviceInfoPackets.c1 && deviceInfoPackets.c2 && deviceInfoPackets.c3 && deviceInfoPackets.c4) {
                // 拼接设备名
                const nameArr = Array.from(deviceInfoPackets.c1).concat(Array.from(deviceInfoPackets.c2));
                const deviceName = String.fromCharCode(...nameArr).replace(/\0/g, '').trim();
                const serialNumber = String.fromCharCode(...deviceInfoPackets.c3).replace(/\0/g, '').trim();
                const modelNumber = String.fromCharCode(...deviceInfoPackets.c4).replace(/\0/g, '').trim();
                // 只更新model/serial
                document.getElementById('modelNumber').textContent = modelNumber || 'null';
                document.getElementById('serialNumber').textContent = serialNumber || 'null';
                // 不再覆盖hardwareVersion/softwareRevision/manufacturer
                clearDeviceInfoPackets();
            }
        }

        // 修改handleResponse，增加C1~C4包处理
        function handleResponse(event) {
            const data = new Uint8Array(event.target.value.buffer);
            
            // 优先检查OTA响应（在OTA进行中）
            if (otaInProgress) {
                if (handleOTAResponse(data)) {
                    return; // OTA响应已处理
                }
            }
            
            // 检查C1~C4包
            if (data[0] === 0xC1 || data[0] === 0xC2 || data[0] === 0xC3 || data[0] === 0xC4) {
                handleDeviceInfoPacket(data);
                return;
            }
            
            // 检查是否是设备状态notify数据包 (20字节，包头包尾都是0xA9)
            if (data.length === 20 && data[0] === 0xA9 && data[19] === 0xA9) {
                // 屏蔽0xA9 notify数据包的日志输出，避免日志被刷屏
                handleNotifyData(data);
                return;
            }
            
            // 检查是否是模式状态notify数据包 (5字节，A5 05 preset mode A5)
            if (data.length === 5 && data[0] === 0xA5 && data[4] === 0xA5 && data[1] === 0x05) {
                const preset = data[2];
                if (preset === 0) {
                    // preset 0 = 全局模式控制
                    handleModeNotifyData(data);
                } else if (preset >= 1 && preset <= 5) {
                    // preset 1-5 = 各预设的模式控制
                    handlePresetModeData(data);
                }
                return;
            }
            
            // 新增：自定义参数包处理（0xaa/0xab包头包尾，15字节）
            if ((data[0] === 0xaa && data[data.length-1] === 0xaa && data.length === 15) ||
                (data[0] === 0xab && data[data.length-1] === 0xab && data.length === 15)) {
                handleCustomProfileData(data);
                return;
            }
            
            // 对于非0xA9数据包，打印data 16进制数据和长度
            log(`Received response: length=${data.length} bytes, content=${Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
            
            // 检查是否是温度设定数据包 (8字节，包头包尾都是0xA3)
            if (data.length === 8 && data[0] === 0xA3 && data[7] === 0xA3) {
                handleTempSettingData(data);
                return;
            }
 
            // 检查是否是Hold Time数据包 (6字节，A7 06 preset time_high time_low A7)
            if (data.length === 6 && data[0] === 0xA7 && data[5] === 0xA7 && data[1] === 0x06) {
                const preset = data[2];
                if (preset === 0) {
                    // preset 0 = 全局Hold Time (旧格式，但data[2]应该是0而不是1)
                    handleTempTimeData(data);
                } else if (preset >= 1 && preset <= 5) {
                    // preset 1-5 = 各预设的Hold Time
                    handlePresetHoldTimeData(data);
                }
                return;
            }

            // 检查是否是统计信息数据包 (A2开头)
            if (data.length >= 5 && data[0] === 0xA2) {
                handleDeviceStatsData(data);
                return;
            }

            // 记录未处理的响应
            const responseText = Array.from(data).map(b => String.fromCharCode(b)).join('');
            log(`Received unhandled response: ${responseText}`);
        }

        // 处理模式状态notify数据
        function handleModeNotifyData(data) {
            const mode = data[3];
            const modeName = MODE_TYPES[mode] || `Unknown (0x${mode.toString(16).padStart(2, '0')})`;
            
            // 更新当前模式
            currentMode = mode;
            
            // 更新模式显示
            updateModeDisplay(mode, modeName);
            
            log(`Received global mode notify: ${modeName} (0x${mode.toString(16).padStart(2, '0')})`);
        }

        // OTA相关函数
        function calculateOTACRC16(crc, data, length) {
            for (let i = 0; i < length; i++) {
                crc ^= (data[i] & 0xFF) << 8;
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x8000) {
                        crc = (crc << 1) ^ 0x1021;
                    } else {
                        crc <<= 1;
                    }
                }
            }
            return crc & 0xFFFF;
        }

        async function loadOTABinFile() {
            try {
                const response = await fetch('./simple_ota.bin');
                if (!response.ok) {
                    throw new Error(`Failed to load simple_ota.bin: ${response.statusText}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                return new Uint8Array(arrayBuffer);
            } catch (error) {
                log(`✗ Failed to load OTA file: ${error.message}`);
                showNotification(`加载固件文件失败: ${error.message}`, 'error');
                throw error;
            }
        }

        async function startFirmwareUpdate() {
            if (!characteristic) {
                log('Error: Device not connected');
                showNotification('设备未连接，无法更新固件', 'error');
                return;
            }

            if (otaInProgress) {
                log('OTA update already in progress');
                showNotification('固件更新正在进行中', 'warning');
                return;
            }

            try {
                // 禁用所有控制按钮
                setOTAModeUI(true);
                
                log('开始固件更新...');
                showNotification('正在加载固件文件...', 'info');
                
                // 加载bin文件
                const data = await loadOTABinFile();
                log(`✓ Loaded firmware file: ${data.length} bytes`);
                
                // 开始OTA
                await startOTA(data);
                
            } catch (error) {
                log(`✗ Firmware update failed: ${error.message}`);
                showNotification(`固件更新失败: ${error.message}`, 'error');
                setOTAModeUI(false);
            }
        }

        async function startOTA(data) {
            otaWriteQueue = [];
            otaInProgress = true;
            
            // 数据填充到16字节整数倍
            const paddedDataLength = Math.ceil(data.length / OTA_CHUNK_SIZE) * OTA_CHUNK_SIZE;
            const paddedData = new Uint8Array(paddedDataLength).fill(0xFF);
            paddedData.set(data);
            
            log(`✓ Padded data length: ${paddedDataLength} bytes`);
            
            // 验证文件大小（主固件应该大于120KB）
            if (paddedDataLength < 120000) {
                throw new Error('固件文件过小，可能不是有效的主固件文件');
            }
            
            // 计算整体CRC16
            const crc16 = calculateOTACRC16(0xFFFF, paddedData, paddedData.length);
            log(`✓ File CRC16: 0x${crc16.toString(16).padStart(4, '0')}`);
            
            // 计算每个2KB块的CRC16
            let blockCrc16 = 0xFFFF;
            otaCrc16Array = [];
            for (let i = 0; i < paddedDataLength; i += OTA_BLOCK_SIZE) {
                const blockData = paddedData.subarray(i, Math.min(i + OTA_BLOCK_SIZE, paddedDataLength));
                blockCrc16 = calculateOTACRC16(blockCrc16, blockData, blockData.length);
                otaCrc16Array.push(blockCrc16);
                log(`Block ${i / OTA_BLOCK_SIZE} CRC16: 0x${blockCrc16.toString(16).padStart(4, '0')}`);
            }
            
            // 构造开始命令
            const startCommand = new Uint8Array(20).fill(0xFF);
            const commandBytes = new TextEncoder().encode("ota start");
            startCommand.set(commandBytes);
            startCommand[10] = (paddedDataLength >> 24) & 0xFF;
            startCommand[11] = (paddedDataLength >> 16) & 0xFF;
            startCommand[12] = (paddedDataLength >> 8) & 0xFF;
            startCommand[13] = paddedDataLength & 0xFF;
            startCommand[14] = (crc16 >> 8) & 0xFF;
            startCommand[15] = crc16 & 0xFF;
            otaWriteQueue.push(startCommand);
            
            // 分包数据
            const totalChunks = paddedDataLength / OTA_CHUNK_SIZE;
            for (let i = 0; i < totalChunks; i++) {
                const chunkWithAddress = new Uint8Array(20).fill(0xFF);
                chunkWithAddress[0] = (i >> 24) & 0xFF;
                chunkWithAddress[1] = (i >> 16) & 0xFF;
                chunkWithAddress[2] = (i >> 8) & 0xFF;
                chunkWithAddress[3] = i & 0xFF;
                const chunkData = paddedData.subarray(i * OTA_CHUNK_SIZE, (i + 1) * OTA_CHUNK_SIZE);
                chunkWithAddress.set(chunkData, 4);
                otaWriteQueue.push(chunkWithAddress);
            }
            
            // 添加结束命令
            const endCommand = new TextEncoder().encode("ota finish");
            const endCommandArray = new Uint8Array(20).fill(0xFF);
            endCommandArray.set(endCommand);
            otaWriteQueue.push(endCommandArray);
            
            // 初始化进度
            updateOTAProgress(0, totalChunks);
            
            // 开始发送
            otaChunkCounter = -1;
            log(`✓ Starting OTA transmission: ${totalChunks} chunks`);
            showNotification('开始固件传输...', 'info');
            
            writeNextOTAChunk();
        }

        async function writeNextOTAChunk() {
            if (otaWriteQueue.length > 0) {
                const chunk = otaWriteQueue.shift();
                try {
                    await characteristic.writeValueWithoutResponse(chunk);
                    
                    if (otaChunkCounter === -1) {
                        // 发送了开始命令，等待1秒后继续
                        otaChunkCounter = 0;
                        setTimeout(() => {
                            writeNextOTAChunk();
                        }, 1000);
                    } else {
                        otaChunkCounter++;
                        
                        // 更新进度
                        const totalChunks = otaChunkCounter + otaWriteQueue.length;
                        updateOTAProgress(otaChunkCounter, totalChunks);
                        
                        // 每128包等待响应
                        if (otaChunkCounter % OTA_CHUNKS_BEFORE_NOTIFY === 0) {
                            log(`Waiting for OK notification (chunk ${otaChunkCounter})...`);
                        } else {
                            setTimeout(() => {
                                writeNextOTAChunk();
                            }, 10);
                        }
                    }
                } catch (error) {
                    log(`✗ Failed to send OTA chunk: ${error.message}`);
                    showNotification(`固件传输失败: ${error.message}`, 'error');
                    setOTAModeUI(false);
                }
            } else {
                // OTA完成
                otaInProgress = false;
                log('✓ OTA Update Complete');
                showNotification('固件更新完成！', 'success');
                setOTAModeUI(false);
                updateOTAProgress(100, 100, true);
            }
        }

        function handleOTAResponse(data) {
            // 检查是否是OTA的"OK"响应
            if (data.length >= 2 && data[0] === 0x4F && data[1] === 0x4B) { // "OK"
                let receivedCrcTransmit = 0xFFFF;
                let receivedCrcFlash = 0xFFFF;
                
                if (data.length > 3) {
                    receivedCrcTransmit = (data[2] << 8) | data[3];
                    log(`Received CRC transmit: 0x${receivedCrcTransmit.toString(16).padStart(4, '0')}`);
                }
                
                if (data.length > 5) {
                    receivedCrcFlash = (data[4] << 8) | data[5];
                    log(`Received CRC flash: 0x${receivedCrcFlash.toString(16).padStart(4, '0')}`);
                }
                
                if (data.length > 3) {
                    // 验证CRC
                    const currentBlockIndex = Math.floor(otaChunkCounter / (OTA_BLOCK_SIZE / OTA_CHUNK_SIZE)) - 1;
                    const expectedCrc = otaCrc16Array[currentBlockIndex];
                    
                    if (receivedCrcTransmit === expectedCrc && receivedCrcFlash === expectedCrc) {
                        log('✓ CRC check passed, continuing...');
                        writeNextOTAChunk();
                    } else {
                        log(`✗ CRC check failed: expected 0x${expectedCrc.toString(16).padStart(4, '0')}`);
                        showNotification('CRC校验失败，停止传输', 'error');
                        setOTAModeUI(false);
                    }
                } else {
                    // 简单的OK响应，继续传输
                    writeNextOTAChunk();
                }
                
                return true; // 表示已处理OTA响应
            }
            
            return false; // 不是OTA响应
        }

        function updateOTAProgress(current, total, completed = false) {
            const progressContainer = document.getElementById('otaProgressContainer');
            const progressBar = document.getElementById('otaProgressBar');
            const progressText = document.getElementById('otaProgressText');
            
            if (completed) {
                progressContainer.style.display = 'none';
                return;
            }
            
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            
            progressContainer.style.display = 'block';
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${percentage}% (${current}/${total})`;
        }

        function setOTAModeUI(otaMode) {
            const updateBtn = document.getElementById('updateFirmwareBtn');
            const buttons = [
                'connectBtn', 'disconnectBtn', 'sessionControlBtn', 'presetBtn',
                'modeControlBtn', 'hapticBtn', 'boostBtn', 'cleaningAssistBtn',
                'refreshStatsBtn', 'sendCustomProfileBtn'
            ];
            
            if (otaMode) {
                // OTA模式：禁用所有按钮除了固件更新按钮
                updateBtn.textContent = 'Updating...';
                updateBtn.disabled = true;
                updateBtn.classList.add('loading');
                
                buttons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = true;
                });
                
                // 禁用所有输入控件
                const inputs = document.querySelectorAll('input, select');
                inputs.forEach(input => {
                    input.disabled = true;
                });
                
            } else {
                // 恢复正常模式
                updateBtn.innerHTML = '<i class="fas fa-download"></i> Update Firmware';
                updateBtn.disabled = !characteristic; // 只有连接时才启用
                updateBtn.classList.remove('loading');
                
                // 恢复固件状态检查
                if (characteristic) {
                    const softwareRevision = document.getElementById('softwareRevision').textContent;
                    updateFirmwareStatus(softwareRevision);
                }
                
                // 重新设置按钮状态（需要考虑连接状态）
                if (characteristic) {
                    buttons.forEach(btnId => {
                        const btn = document.getElementById(btnId);
                        if (btn && btnId !== 'connectBtn') {
                            btn.disabled = false;
                        }
                    });
                    
                    // 重新启用输入控件
                    const inputs = document.querySelectorAll('input, select');
                    inputs.forEach(input => {
                        input.disabled = false;
                    });
                    
                    // 禁用连接按钮，启用断开按钮
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                } else {
                    // 设备未连接，只启用连接按钮
                    document.getElementById('connectBtn').disabled = false;
                    buttons.forEach(btnId => {
                        const btn = document.getElementById(btnId);
                        if (btn && btnId !== 'connectBtn') {
                            btn.disabled = true;
                        }
                    });
                }
                
                // 隐藏进度条和固件状态
                document.getElementById('otaProgressContainer').style.display = 'none';
                document.getElementById('firmwareStatusContainer').style.display = 'none';
            }
        }

        // 处理设备状态notify数据
        function handleNotifyData(data) {
            notifyPacketCount++;
            
            // 验证数据包格式
            if (data[1] !== 20) {
                log(`Invalid notify packet length field: ${data[1]}`);
                return;
            }
            
            // 解析数据包
            const preset = data[3];
            const tempSetting =    globalTempF[preset];//data[4];
            const ledPreset = data[6];
            const sessionEnable = data[7];
            const autoShutTime = data[8];
            const remainTime = data[9];
            const realTemp = (data[10] << 8) | data[11]; // 温度合并
            const tempUnit = data[12] === 0x0f ? '℉' : '℃'; // 0x0f=华氏度, 0x0c=摄氏度
            const sessionRemainTime = data[13];
            const hapticFeedback = data[14];
            const sessionBoost = data[15];
            const batteryLevel = data[16];
            const chargeState = data[17];
            const brightness = data[18];
            
            // 更新显示（如果没有在拖动滑块）
            updateDeviceStatus({
                preset,
                tempSetting,
                realTemp,
                tempUnit,
                ledPreset,
                sessionEnable,
                autoShutTime,
                remainTime,
                sessionRemainTime,
                hapticFeedback,
                sessionBoost,
                batteryLevel,
                chargeState,
                brightness
            }, isDraggingSlider); // 传递拖动状态
            
            // 更新温度图表
            if (realTemp > 0 && notificationsEnabled) {
                addTemperaturePoint(realTemp);
            }
            
            // 更新原始数据显示
            const rawDataHex = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
            document.getElementById('rawData').textContent = rawDataHex;
            document.getElementById('packetCount').textContent = notifyPacketCount;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            
            //log(`Received device status notify: temp=${realTemp}°${tempUnit}, battery=${batteryLevel}%, preset=${preset}`);
        }


        
        function handleTempTimeData(data) {
            if (data[1] !== 6) {
                log(`Invalid temp time packet length field: ${data[1]}`);
                return;
            }    
            holdTime = (data[3] << 8) | data[4];
            
            // 更新Hold Time输入框（只在不拖动时更新）
            if (!draggingSliders.has('holdTime')) {
                document.getElementById('holdTime').value = holdTime;
                updateHoldTimeDisplay(holdTime);
            }
            
            log(`Received global hold time: ${holdTime} seconds`);
        }

        // 处理温度设定数据包 - 格式: 0xA3 + 长度(8) + 预设索引 + 华氏温度(2字节) + 摄氏温度(2字节) + 0xA3
        function handleTempSettingData(data) {
            // 验证数据包格式
            if (data[1] !== 8) {
                log(`Invalid temp setting packet length field: ${data[1]}`);
                return;
            }
            
            // 解析数据包
            const presetIndex = data[2]; // 预设索引 (1-5)
            const tempF = (data[3] << 8) | data[4]; // 华氏温度
            const tempC = (data[5] << 8) | data[6]; // 摄氏温度
            
            // 验证预设索引范围
            if (presetIndex < 1 || presetIndex > 5) {
                log(`Invalid preset index: ${presetIndex}`);
                return;
            }
            
            // 保存到全局变量
            globalPresetIndex = presetIndex;
            globalTempF[presetIndex] = tempF;
            globalTempC[presetIndex] = tempC;
            
            // 更新温度预设输入框
            document.getElementById(`tempF${presetIndex}`).value = tempF;
            
            // 显示原始数据
            const rawDataHex = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
            
            log(`Received temp setting for preset ${presetIndex}: ${tempF}°F`);
            log(`  Raw data: ${rawDataHex}`);
        }

        // 请求设备统计信息 - 发送B2命令
        async function requestDeviceStats() {
            if (!characteristic) {
                log('Error: Device not connected');
                showNotification('设备未连接，无法获取统计信息', 'error');
                return;
            }

            try {
                // 构造B2命令数据包：0xB2 + 0x04 + 0xFF + 0xB2
                const statsCommand = new Uint8Array([0xB2, 0x04, 0xFF, 0xB2]);
                
                // 发送统计信息请求命令
                await characteristic.writeValue(statsCommand);
                
                const packetHex = Array.from(statsCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                
                log(`✓ Device statistics request sent`);
                log(`  Packet data: ${packetHex}`);
                
                showNotification('正在获取设备统计信息...', 'info', 2000);
                
            } catch (error) {
                log(`✗ Failed to request device statistics: ${error.message}`);
                showNotification(`获取统计信息失败: ${error.message}`, 'error');
            }
        }

        // 处理设备统计信息数据包 - 格式: 0xA2 + 长度 + 数据 + 0xA2
        function handleDeviceStatsData(data) {
            // 显示原始数据
            const rawDataHex = Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
            log(`Received device statistics data (${data.length} bytes):`);
            log(`  Raw data: ${rawDataHex}`);
            
            // 验证A2数据包格式：至少3字节（0xA2 + 长度 + 0xA2）
            if (data.length < 3) {
                log(`✗ A2 packet too short: ${data.length} bytes`);
                return;
            }
            
            // 验证包头和包尾
            if (data[0] !== 0xA2 || data[data.length - 1] !== 0xA2) {
                log(`✗ Invalid A2 packet format - missing header/footer`);
                return;
            }
            
            // 验证长度字段
            const declaredLength = data[1];
            if (declaredLength !== data.length) {
                log(`✗ A2 packet length mismatch - declared: ${declaredLength}, actual: ${data.length}`);
                return;
            }
            
            // 解析不同类型的A2数据包
            if (data.length === 19) {
                // 19字节的统计信息数据包
                try {
                    // 从数据包中提取统计信息（根据新的A2 13数据结构）
                    const stats = {
                        favoriteTempF: (data[2] << 8) | data[3],       // 喜爱温度华氏度
                        favoriteTempC: (data[4] << 8) | data[5],       // 喜爱温度摄氏度
                        totalHeatingCycles: (data[6] << 8) | data[7],  // 总加热次数
                        mostCyclesInDay: (data[8] << 8) | data[9],     // 单日最多加热次数
                        chargeCycles: (data[10] << 8) | data[11],      // 充电循环次数
                        profile: data[12],                             // 配置文件
                        lightMode: data[13],                           // 灯光模式
                        deviceResets: (data[14] << 8) | data[15],      // 设备重置总次数
                        favoriteHeatingTime: (data[16] << 8) | data[17] // 喜爱加热时间
                    };
                    
                    // 更新显示
                    updateDeviceStatsDisplay(stats);
                    
                    log(`✓ Device statistics parsed successfully:`);
                    log(`  Favorite Temperature: ${stats.favoriteTempF}°F (${stats.favoriteTempC}°C)`);
                    log(`  Total Heating Cycles: ${stats.totalHeatingCycles}`);
                    log(`  Most Cycles in Day: ${stats.mostCyclesInDay}`);
                    log(`  Charge Cycles: ${stats.chargeCycles}`);
                    log(`  Profile: ${stats.profile}`);
                    log(`  Light Mode: ${stats.lightMode}`);
                    log(`  Device Resets: ${stats.deviceResets}`);
                    log(`  Favorite Heating Time: ${stats.favoriteHeatingTime}s`);
                    
                    showNotification('设备统计信息获取成功！', 'success', 2000);
                    
                } catch (error) {
                    log(`✗ Failed to parse 19-byte A2 statistics: ${error.message}`);
                    showNotification('统计信息解析失败', 'error');
                }
            } else if (data.length === 7) {
                // 7字节的A2数据包 - Session Total Time
                try {
                    // 解析Session Total Time (4字节，大端序)
                    const sessionTotalTime = (data[2] << 24) | (data[3] << 16) | (data[4] << 8) | data[5];
                    
                    // 更新Session Total Time显示
                    updateSessionTotalTimeDisplay(sessionTotalTime);
                    
                    log(`✓ Session Total Time received: ${sessionTotalTime} seconds`);
                    log(`  Raw time data: ${Array.from(data.slice(2, -1)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
                    
                } catch (error) {
                    log(`✗ Failed to parse 7-byte A2 session time: ${error.message}`);
                }
            } else {
                // 其他长度的A2数据包
                log(`✓ Received A2 packet (${data.length} bytes) - data: ${Array.from(data.slice(2, -1)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
            }
        }

        // 更新设备统计信息显示
        function updateDeviceStatsDisplay(stats) {
            document.getElementById('favoriteTemp').textContent = `${stats.favoriteTempF}°F (${stats.favoriteTempC}°C)`;
            document.getElementById('totalHeatingCycles').textContent = stats.totalHeatingCycles;
            document.getElementById('mostCyclesInDay').textContent = stats.mostCyclesInDay;
            document.getElementById('chargeCycles').textContent = stats.chargeCycles;
            
            // Profile: 显示数字对应的模式文字 (根据MODE_TYPES映射)
            const PROFILE_MODE_MAP = {
                0xA1: 'Steady',
                0xB1: 'Ascent', 
                0xC1: 'Descent',
                0xD1: 'Valley',
                0xE1: 'Hill',
                0xF1: 'Custom'
            };
            const profileText = PROFILE_MODE_MAP[stats.profile] || `Unknown (${stats.profile})`;
            document.getElementById('profile').textContent = profileText;
            
            // Light Mode: 显示灯光对应模式文字
            const lightModeText = LED_COLORS[stats.lightMode] || `Unknown (${stats.lightMode})`;
            document.getElementById('lightMode').textContent = lightModeText;
            
            document.getElementById('deviceResets').textContent = stats.deviceResets;
            document.getElementById('favoriteHeatingTime').textContent = `${stats.favoriteHeatingTime}s`;
        }

        // 更新Session Total Time显示
        function updateSessionTotalTimeDisplay(totalTimeSeconds) {
            // 将秒数转换为更易读的格式
            const hours = Math.floor(totalTimeSeconds / 3600);
            const minutes = Math.floor((totalTimeSeconds % 3600) / 60);
            const seconds = totalTimeSeconds % 60;
            
            let timeStr = '';
            if (hours > 0) {
                timeStr = `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                timeStr = `${minutes}m ${seconds}s`;
            } else {
                timeStr = `${seconds}s`;
            }
            
            document.getElementById('sessionTotalTime').textContent = timeStr;
        }

        // 重置设备统计信息显示
        function resetDeviceStats() {
            document.getElementById('favoriteTemp').textContent = '--';
            document.getElementById('totalHeatingCycles').textContent = '--';
            document.getElementById('mostCyclesInDay').textContent = '--';
            document.getElementById('chargeCycles').textContent = '--';
            document.getElementById('profile').textContent = '--';
            document.getElementById('lightMode').textContent = '--';
            document.getElementById('deviceResets').textContent = '--';
            document.getElementById('favoriteHeatingTime').textContent = '--';
            document.getElementById('sessionTotalTime').textContent = '--';
        }

                // 更新设备状态显示
        function updateDeviceStatus(status, skipSliderUpdate = false) {
            // 更新预设显示和同步当前预设值
            currentPreset = status.preset;
            document.getElementById('presetBtn').textContent = status.preset;
            
            document.getElementById('tempSetting').textContent = status.tempSetting + '°F';
            document.getElementById('realTemp').textContent = status.realTemp + '°F';
            
            // 更新当前preset对应的模式显示
            updateCurrentPresetModeDisplay(status.preset);
           //  document.getElementById('tempUnit').textContent = status.tempUnit;
           
            // 更新图表信息显示
            setTimeout(() => updateChartInfo(), 100);
            
            // 更新LED预设显示和选择框
            const ledColorName = LED_COLORS[status.ledPreset] || `Unknown (0x${status.ledPreset.toString(16).padStart(2, '0')})`;
            document.getElementById('ledPreset').textContent = ledColorName;
            
            // 更新选择框
            const ledSelect = document.getElementById('ledPresetSelect');
            const ledHexValue = '0x' + status.ledPreset.toString(16).padStart(2, '0').toUpperCase();
            ledSelect.value = ledHexValue;
            
            // 更新LED颜色预览
            updateLedPreview(status.ledPreset);
            
            // 同步状态跟踪变量
            currentB9State.byte3 = status.preset;
            currentB9State.byte6 = status.ledPreset;
            currentB9State.byte8 = status.autoShutTime;
            currentB9State.byte10 = status.sessionEnable ? 0xaa : 0x00;
            currentB9State.byte11 = status.hapticFeedback ? 0xAA : 0x00;
            currentB9State.byte12 = status.sessionBoost;
            currentB9State.byte13 = status.brightness;
            
            // 更新Session控制按钮
            updateSessionControlButton(status.sessionEnable);
            
            // 只在非拖动状态下更新滑块值
            if (!skipSliderUpdate) {
                // 只更新不在拖动中的滑块
                if (!draggingSliders.has('autoShutTime')) {
                    document.getElementById('autoShutTime').value = status.autoShutTime;
                    updateAutoShutDisplay(status.autoShutTime);
                }
                
                if (!draggingSliders.has('brightness')) {
                    document.getElementById('brightness').value = status.brightness;
                    updateBrightnessDisplay(status.brightness);
                }
            }
            
            document.getElementById('remainTime').textContent = status.remainTime;
            document.getElementById('sessionRemainTime').textContent = status.sessionRemainTime;
            document.getElementById('batteryLevel').textContent = status.batteryLevel + '%';
            
            // 更新Haptic和Boost按钮显示
            updateHapticButton(status.hapticFeedback);
            updateBoostButton(currentB9State.byte12);
            
            // 充电状态显示
            const chargeStateText = status.chargeState === 0XAA ? 'Charging' : 'Not Charging';
            document.getElementById('chargeState').textContent = chargeStateText;
        }



        // 旧的updateConnectionStatus函数已被updateConnectionStatusWithAnimation替代

        async function connectDevice() {
            try {
                updateConnectionStatusWithAnimation(false, true); // 显示连接中状态
                setButtonLoading('connectBtn', true);
                log('Searching for Bluetooth devices...');
                
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['0000fee7-0000-1000-8000-00805f9b34fb'] }
                    ],
                    optionalServices: [SERVICE_UUID, DEVICE_INFO_SERVICE_UUID]
                });

                log(`Found device: ${bluetoothDevice.name}`);
                
                const server = await bluetoothDevice.gatt.connect();
                log('GATT server connected successfully');
                
                const service = await server.getPrimaryService(SERVICE_UUID);
                log('Service obtained successfully');
                
                characteristic = await service.getCharacteristic(TX_CHARACTERISTIC_UUID);
                log('TX characteristic obtained successfully');
                
                // Get RX characteristic for listening to responses
                rxCharacteristic = await service.getCharacteristic(RX_CHARACTERISTIC_UUID);
                log('RX characteristic obtained successfully');
                
                // Enable notifications to receive responses
                await rxCharacteristic.startNotifications();
                rxCharacteristic.addEventListener('characteristicvaluechanged', handleResponse);
                log('Response listener enabled successfully');

                // Listen for device disconnection
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
                
                updateConnectionStatusWithAnimation(true);
                log('Bluetooth device connected successfully!');
                
                // 新增：连接成功后自动发送B1指令获取设备信息
                setTimeout(async () => {
                    if (characteristic) {
                        clearDeviceInfoPackets();
                        const b1Cmd = new Uint8Array([0xB1, 0x04, 0xFF, 0xB1]);
                        await characteristic.writeValue(b1Cmd);
                        log('B1指令已发送，等待设备信息C1~C4包...');
                    }
                }, 500);
                
                // 新增：自动读取software revision和manufacturer
                setTimeout(async () => {
                    await readSoftwareAndManufacturer(server);
                }, 700);
                
                // 自动同步时间
                setTimeout(async () => {
                    await syncTime();
                }, 1000); // 延迟1秒后自动同步时间
                
                // 自动启用实时监控
                setTimeout(async () => {
                    if (rxCharacteristic && !notificationsEnabled) {
                        await toggleNotifications();
                    }
                }, 1500); // 延迟1.5秒后自动启用实时监控
                
                // 获取设备统计信息
                setTimeout(async () => {
                    await requestDeviceStats();
                }, 2000); // 延迟2秒后获取设备统计信息
                
            } catch (error) {
                log(`Connection failed: ${error.message}`);
                updateConnectionStatusWithAnimation(false);
                showNotification(`连接失败: ${error.message}`, 'error');
            } finally {
                setButtonLoading('connectBtn', false);
            }
        }

        function onDisconnected() {
            log('Device disconnected');
            updateConnectionStatusWithAnimation(false);
            bluetoothDevice = null;
            characteristic = null;
            rxCharacteristic = null;
        }

        async function disconnectDevice() {
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
                log('Device disconnected actively');
            }
            updateConnectionStatusWithAnimation(false);
            rxCharacteristic = null;
        }









        // Check browser support
        if (!navigator.bluetooth) {
            log('Error: This browser does not support Web Bluetooth API');
            log('Please use Chrome, Edge, or other browsers that support Web Bluetooth');
            document.getElementById('connectBtn').disabled = true;
        } else {
            log('Browser supports Web Bluetooth API');
        }

        // Page load initialization
        window.addEventListener('load', function() {
            
            // 设置Hold Time默认值
            document.getElementById('holdTime').value = holdTime;
            updateHoldTimeDisplay(holdTime);
            
            // 设置Auto Shut Time默认值
            document.getElementById('autoShutTime').value = currentB9State.byte8;
            updateAutoShutDisplay(currentB9State.byte8);
            
            // 设置Brightness默认值
            document.getElementById('brightness').value = currentB9State.byte13;
            updateBrightnessDisplay(currentB9State.byte13);
            
            // 初始化LED预览
            updateLedPreview(0x00);
            
            // 初始化模式显示
            updateModeDisplay(currentMode, MODE_TYPES[currentMode]);
            
            // 初始化Haptic和Boost按钮显示
            updateHapticButton(currentB9State.byte11 === 0xAA);
            updateBoostButton(currentB9State.byte12);
            
            // 初始化CleaningAssist按钮显示
            updateCleaningAssistButton(cleaningAssistEnabled);
            
            // 初始化preset控件显示
            for (let i = 1; i <= 5; i++) {
                updatePresetHoldTimeDisplay(i, presetHoldTimes[i]);
                // Mode选择器默认值已在HTML中设置，这里不需要特别处理
            }
            
            // 初始化当前preset对应的模式显示
            updateCurrentPresetModeDisplay(currentPreset);
            
            // 确保Boost按钮初始状态为禁用（只有加热时才能使用）
            document.getElementById('boostBtn').disabled = true;
            
            // 初始化温度图表
            setTimeout(() => {
                initTemperatureChart();
                log('Temperature chart initialized');
            }, 500); // 延迟初始化以确保DOM完全加载
            
            // 添加页面加载动画
            const cards = document.querySelectorAll('.card');
            cards.forEach((card, index) => {
                card.style.animationDelay = `${index * 0.1}s`;
            });
            
            // 显示欢迎通知
            setTimeout(() => {
                showNotification('PY32F071 设备控制工具已就绪', 'info', 2000);
            }, 1000);
        });

        // 切换notifications开关
        async function toggleNotifications() {
            if (!rxCharacteristic) {
                log('Error: RX characteristic not available');
                showNotification('设备未连接，无法启用监控', 'error');
                return;
            }

            try {
                const toggle = document.getElementById('notifyToggle');
                
                if (notificationsEnabled) {
                    // 禁用notifications
                    await rxCharacteristic.stopNotifications();
                    notificationsEnabled = false;
                    document.getElementById('notifyStatus').textContent = 'Disabled';
                    document.getElementById('deviceStatusInfo').style.display = 'none';
                    toggle.checked = false;
                    log('Device status notifications disabled');
                    showNotification('实时监控已关闭', 'info', 2000);
                } else {
                    // 启用notifications
                    await rxCharacteristic.startNotifications();
                    notificationsEnabled = true;
                    document.getElementById('notifyStatus').textContent = 'Enabled';
                    document.getElementById('deviceStatusInfo').style.display = 'block';
                    toggle.checked = true;
                    log('Device status notifications enabled');
                    showNotification('实时监控已开启', 'success', 2000);
                }
            } catch (error) {
                log(`Failed to toggle notifications: ${error.message}`);
                showNotification(`监控切换失败: ${error.message}`, 'error');
            }
        }

        // 同步时间功能 - 发送格式：b1 09 year(2 byte) month day hour minute b1
        async function syncTime() {
            if (!characteristic) {
                log('Error: Device not connected');
                return;
            }

            try {
                // 获取当前时间
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1; // JavaScript月份从0开始
                const day = now.getDate();
                const hour = now.getHours();
                const minute = now.getMinutes();

                // 构造时间同步数据包：b1 09 year(2 byte) month day hour minute b1
                const timePacket = new Uint8Array(9);
                timePacket[0] = 0xB1;  // 起始标识
                timePacket[1] = 0x09;  // 命令类型 - 时间同步
                timePacket[2] = (year >> 8) & 0xFF;  // 年份高字节
                timePacket[3] = year & 0xFF;         // 年份低字节
                timePacket[4] = month;               // 月份
                timePacket[5] = day;                 // 日期
                timePacket[6] = hour;                // 小时
                timePacket[7] = minute;              // 分钟
                timePacket[8] = 0xB1;  // 结束标识

                // 发送时间同步数据包
                await characteristic.writeValue(timePacket);
                
                const timeStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')} ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                const packetHex = Array.from(timePacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                
                                 log(`✓ Time sync packet sent: ${timeStr}`);
                 log(`  Packet data: ${packetHex}`);
                 
             } catch (error) {
                 log(`✗ Failed to sync time: ${error.message}`);
             }
         }

         // 设置温度预设 - 发送格式：0xA3 + 8 + 预设索引 + 华氏温度(2字节) + 摄氏温度(2字节) + 0xA3
         async function setTemperature(presetIndex, tempF) {
             if (!characteristic) {
                 log('Error: Device not connected');
                 return;
             }

             // 验证温度范围
             const temperature = parseInt(tempF);
             if (temperature < 250 || temperature > 650) {
                 log(`Error: Temperature ${temperature}°F is out of range (250-650°F)`);
                 // 恢复之前的值
                 document.getElementById(`tempF${presetIndex}`).value = document.getElementById(`tempF${presetIndex}`).defaultValue;
                 return;
             }

             try {
                 // 华氏度转摄氏度 (C = (F - 32) * 5/9)
                 const tempC = Math.round((temperature - 32) * 5 / 9);

                 // 构造温度设置数据包：0xA3 + 8 + 预设索引 + 华氏温度(2字节) + 摄氏温度(2字节) + 0xA3
                 const tempPacket = new Uint8Array(8);
                 tempPacket[0] = 0xB3;                    // 起始标识
                 tempPacket[1] = 8;                       // 数据长度
                 tempPacket[2] = presetIndex;             // 预设索引 (1-5)
                 tempPacket[3] = (temperature >> 8) & 0xFF;  // 华氏温度高字节
                 tempPacket[4] = temperature & 0xFF;         // 华氏温度低字节
                 tempPacket[5] = (tempC >> 8) & 0xFF;        // 摄氏温度高字节
                 tempPacket[6] = tempC & 0xFF;               // 摄氏温度低字节
                 tempPacket[7] = 0xB3;                    // 结束标识

                 // 发送温度设置数据包
                 await characteristic.writeValue(tempPacket);
                 
                 const packetHex = Array.from(tempPacket).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                 
                 log(`✓ Temperature preset ${presetIndex} set to ${temperature}°F (${tempC}°C)`);
                 log(`  Packet data: ${packetHex}`);
                 
                           } catch (error) {
                  log(`✗ Failed to set temperature: ${error.message}`);
              }
          }

          // 通用B9命令发送函数 - 可设置任意字节
          async function sendB9Command(updates, description) {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              try {
                  // 更新状态
                  for (const [bytePos, value] of Object.entries(updates)) {
                      currentB9State[bytePos] = value;
                  }

                  // 构造B9命令数据包：0xB9 + 长度(20) + 数据字节 + 0xB9
                  const command = new Uint8Array(20);
                  command[0] = 0xB9;        // 起始标识
                  command[1] = 20;          // 数据长度
                  command[2] = 0x00;
                  command[3] = currentB9State.byte3 || 0x01;   // 预设值 (1-5)
                  command[4] = 0x00;
                  command[5] = 0x00;
                  command[6] = currentB9State.byte6 || 0x00;   // LED值
                  command[7] = 0x00;
                  command[8] = currentB9State.byte8 || 0x00;   // Auto Shut Time (0-30分钟)
                  command[9] = 0x0f;
                  command[10] = currentB9State.byte10 || 0x00; // Session状态
                  command[11] = currentB9State.byte11 || 0x00;
                  command[12] = currentB9State.byte12 || 0x00; // 未来扩展
                  command[13] = currentB9State.byte13 || 0x00; // Brightness (0-100)
                  command[14] = currentB9State.byte14 || 0x00; // 未来扩展
                  command[15] = currentB9State.byte15 || 0x00; // 未来扩展
                  command[16] = currentB9State.byte16 || 0x00; // 未来扩展
                  command[17] = currentB9State.byte17 || 0x00; // 未来扩展
                  command[18] = currentB9State.byte18 || 0x00; // 未来扩展
                  command[19] = 0xB9;       // 结束标识

                  // 发送命令
                  await characteristic.writeValue(command);
                  
                  const packetHex = Array.from(command).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  
                  log(`✓ ${description}`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 显示更新的字节
                  const updatedBytes = Object.entries(updates).map(([pos, val]) => 
                      `${pos}: 0x${val.toString(16).padStart(2, '0')}`
                  ).join(', ');
                  log(`  Updated bytes: ${updatedBytes}`);
                  
              } catch (error) {
                  log(`✗ Failed to send B9 command (${description}): ${error.message}`);
              }
          }

          // 设置LED预设 - 调用通用B9命令函数
          async function setLedPreset(ledValue) {
              // 解析十六进制值
              const ledPreset = parseInt(ledValue, 16);
              const colorName = LED_COLORS[ledPreset] || 'Unknown';
              
              // 验证LED值范围
              if (!(ledPreset in LED_COLORS)) {
                  log(`Error: Invalid LED color value ${ledValue}`);
                  return;
              }

              // 更新LED预览
              updateLedPreview(ledPreset);

              // 调用通用B9命令函数，只更新LED值（第6字节）
              await sendB9Command(
                  { byte6: ledPreset },
                  `LED color set to ${colorName} (${ledValue})`
              );
              
              showNotification(`LED颜色已设置为 ${colorName}`, 'success', 2000);
          }

          // 更新Session控制按钮状态并控制其他控件的启用/禁用
          function updateSessionControlButton(isSessionEnabled) {
              const sessionBtn = document.getElementById('sessionControlBtn');
              
              // 获取需要控制的元素
              const presetBtn = document.getElementById('presetBtn');
              const autoShutTimeInput = document.getElementById('autoShutTime');
              const holdTimeInput = document.getElementById('holdTime');
              const brightnessInput = document.getElementById('brightness');
              const ledPresetSelect = document.getElementById('ledPresetSelect');
              const modeControlBtn = document.getElementById('modeControlBtn');
              const hapticBtn = document.getElementById('hapticBtn');
              const boostBtn = document.getElementById('boostBtn');
              const cleaningAssistBtn = document.getElementById('cleaningAssistBtn');
              
              // 温度预设输入框
              const tempInputs = [
                  document.getElementById('tempF1'),
                  document.getElementById('tempF2'),
                  document.getElementById('tempF3'),
                  document.getElementById('tempF4'),
                  document.getElementById('tempF5')
              ];
              
              if (isSessionEnabled) {
                  // 加热中：按钮变红色，禁用其他控件
                  sessionBtn.textContent = 'Stop Heating';
                  sessionBtn.style.backgroundColor = '#dc3545'; // 红色
                  sessionBtn.style.color = 'white';
                  
                  // 禁用其他控制项并添加视觉提示
                  presetBtn.disabled = true;
                  presetBtn.classList.add('heating-disabled');
                  
                  autoShutTimeInput.disabled = true;
                  autoShutTimeInput.classList.add('heating-disabled');
                  
                  holdTimeInput.disabled = true;
                  holdTimeInput.classList.add('heating-disabled');
                  
                  brightnessInput.disabled = true;
                  brightnessInput.classList.add('heating-disabled');
                  
                  ledPresetSelect.disabled = true;
                  ledPresetSelect.classList.add('heating-disabled');
                  
                  modeControlBtn.disabled = true;
                  modeControlBtn.classList.add('heating-disabled');
                  
                  hapticBtn.disabled = true;
                  hapticBtn.classList.add('heating-disabled');
                  
                  // Boost按钮在加热时启用
                  boostBtn.disabled = false;
                  boostBtn.classList.remove('heating-disabled');
                  
                  // CleaningAssist按钮在加热时禁用
                  cleaningAssistBtn.disabled = true;
                  cleaningAssistBtn.classList.add('heating-disabled');
                  
                  // 禁用所有温度预设输入框并添加视觉提示
                  tempInputs.forEach(input => {
                      if (input) {
                          input.disabled = true;
                          input.classList.add('heating-disabled');
                          // 为父容器也添加禁用类
                          const container = input.closest('.preset-card');
                          if (container) container.classList.add('heating-disabled');
                      }
                  });
                  
                  // 禁用preset控件
                  for (let i = 1; i <= 5; i++) {
                      const holdTimeSlider = document.getElementById(`presetHoldTime${i}`);
                      const modeSelect = document.getElementById(`presetMode${i}`);
                      if (holdTimeSlider) {
                          holdTimeSlider.disabled = true;
                          holdTimeSlider.classList.add('heating-disabled');
                      }
                      if (modeSelect) {
                          modeSelect.disabled = true;
                          modeSelect.classList.add('heating-disabled');
                      }
                  }
                  
                  
              } else {
                  // 停止加热：按钮变绿色，启用其他控件
                  sessionBtn.textContent = 'Press to Heat';
                  sessionBtn.style.backgroundColor = '#28a745'; // 绿色
                  sessionBtn.style.color = 'white';
                  
                  // 只有在设备连接时才启用其他控制项
                  const isConnected = !sessionBtn.disabled; // 如果session按钮没被禁用，说明设备已连接
                  
                  if (isConnected) {
                      presetBtn.disabled = false;
                      presetBtn.classList.remove('heating-disabled');
                      
                      autoShutTimeInput.disabled = false;
                      autoShutTimeInput.classList.remove('heating-disabled');
                      
                      holdTimeInput.disabled = false;
                      holdTimeInput.classList.remove('heating-disabled');
                      
                      brightnessInput.disabled = false;
                      brightnessInput.classList.remove('heating-disabled');
                      
                      ledPresetSelect.disabled = false;
                      ledPresetSelect.classList.remove('heating-disabled');
                      
                      modeControlBtn.disabled = false;
                      modeControlBtn.classList.remove('heating-disabled');
                      
                      hapticBtn.disabled = false;
                      hapticBtn.classList.remove('heating-disabled');
                      
                      // Boost按钮在非加热时禁用
                      boostBtn.disabled = true;
                      boostBtn.classList.add('heating-disabled');
                      
                      // CleaningAssist按钮在非加热时启用
                      cleaningAssistBtn.disabled = false;
                      cleaningAssistBtn.classList.remove('heating-disabled');
                      
                      // 启用所有温度预设输入框并移除视觉提示
                      tempInputs.forEach(input => {
                          if (input) {
                              input.disabled = false;
                              input.classList.remove('heating-disabled');
                              // 为父容器也移除禁用类
                              const container = input.closest('.preset-card');
                              if (container) container.classList.remove('heating-disabled');
                          }
                      });
                      
                      // 启用preset控件
                      for (let i = 1; i <= 5; i++) {
                          const holdTimeSlider = document.getElementById(`presetHoldTime${i}`);
                          const modeSelect = document.getElementById(`presetMode${i}`);
                          if (holdTimeSlider) {
                              holdTimeSlider.disabled = false;
                              holdTimeSlider.classList.remove('heating-disabled');
                          }
                          if (modeSelect) {
                              modeSelect.disabled = false;
                              modeSelect.classList.remove('heating-disabled');
                          }
                      }
                  }

              }
          }

          // 切换Session状态 - 调用通用B9命令函数
          async function toggleSession() {
              // 获取当前按钮状态来判断要执行的操作
              const sessionBtn = document.getElementById('sessionControlBtn');
              const isCurrentlyHeating = sessionBtn.textContent === 'Stop Heating';
              const newSessionState = isCurrentlyHeating ? 0x00 : 0xaa;
              const action = isCurrentlyHeating ? 'stop' : 'start';
              
              // 调用通用B9命令函数，只更新Session状态（第10字节）
              await sendB9Command(
                  { byte10: newSessionState },
                  `Session ${action} command sent`
              );
          }

          // 切换预设挡位 - 循环切换1→2→3→4→5→1
          async function switchPreset() {
              // 循环切换预设值
              currentPreset = currentPreset >= 5 ? 1 : currentPreset + 1;
              
              // 更新按钮显示
              document.getElementById('presetBtn').textContent = currentPreset;
              
              // 更新当前preset对应的模式显示
              updateCurrentPresetModeDisplay(currentPreset);
              
              // 发送预设切换命令 - 使用B9命令格式，第3字节为预设值
              await sendB9Command(
                  { byte3: currentPreset },
                  `Preset switched to ${currentPreset}`
              );
              
              log(`✓ Preset switched to ${currentPreset}`);
          }

          // 设置Auto Shut Time - 发送B9命令第8字节
          async function setAutoShutTime(minutes) {
              // 验证时间范围
              const autoShutTime = parseInt(minutes);
              if (autoShutTime < 0 || autoShutTime > 30) {
                  log(`Error: Auto Shut Time ${autoShutTime} is out of range (0-30 minutes)`);
                  // 恢复之前的值
                  document.getElementById('autoShutTime').value = currentB9State.byte8 || 2;
                  return;
              }

              // 调用通用B9命令函数，只更新Auto Shut Time（第8字节）
              await sendB9Command(
                  { byte8: autoShutTime },
                  `Auto Shut Time set to ${autoShutTime} minutes`
              );
          }

          // 设置Hold Time - 发送B7命令格式：B7 06 01 holdTime(high) holdTime(low) B7
          async function setHoldTime(seconds) {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              // 验证时间范围
              const holdTime = parseInt(seconds);
              if (holdTime < 10 || holdTime > 90) {
                  log(`Error: Hold Time ${holdTime} is out of range (10-90 seconds)`);
                  // 恢复之前的值
                  document.getElementById('holdTime').value = window.holdTime || 30;
                  return;
              }

              try {
                  // 构造B7命令数据包：B7 06 00 holdTime(high) holdTime(low) B7 (preset 0 = 全局Hold Time)
                  const holdTimeCommand = new Uint8Array(6);
                  holdTimeCommand[0] = 0xB7;                      // 起始标识
                  holdTimeCommand[1] = 0x06;                      // 数据长度
                  holdTimeCommand[2] = 0x00;                      // preset 0 (全局Hold Time)
                  holdTimeCommand[3] = (holdTime >> 8) & 0xFF;    // holdTime高字节
                  holdTimeCommand[4] = holdTime & 0xFF;           // holdTime低字节
                  holdTimeCommand[5] = 0xB7;                      // 结束标识

                  // 发送Hold Time设置命令
                  await characteristic.writeValue(holdTimeCommand);
                  
                  const packetHex = Array.from(holdTimeCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  
                  log(`✓ Hold Time set to ${holdTime} seconds`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 更新全局holdTime变量
                  window.holdTime = holdTime;
                  
              } catch (error) {
                  log(`✗ Failed to set Hold Time: ${error.message}`);
              }
          }

          // 更新亮度显示值（实时）
          function updateBrightnessDisplay(value) {
              document.getElementById('brightnessDisplay').textContent = value;
          }

          // 更新Auto Shut Time显示值（实时）
          function updateAutoShutDisplay(value) {
              document.getElementById('autoShutDisplay').textContent = value + ' min';
          }

          // 更新Hold Time显示值（实时）
          function updateHoldTimeDisplay(value) {
              document.getElementById('holdTimeDisplay').textContent = value + ' sec';
          }

          // 滑块拖动状态管理
          function startSliderDrag(sliderId) {
              draggingSliders.add(sliderId);
              isDraggingSlider = draggingSliders.size > 0;
              
              // 清除之前的超时
              if (sliderTimeouts[sliderId]) {
                  clearTimeout(sliderTimeouts[sliderId]);
              }
              
              // 设置超时，如果3秒内没有操作就恢复接收更新
              sliderTimeouts[sliderId] = setTimeout(() => {
                  endSliderDrag(sliderId);
                  log(`Slider ${sliderId} drag timeout - resuming updates`);
              }, 3000);
              
              // log(`Started dragging slider: ${sliderId}, total dragging: ${draggingSliders.size}`);
          }

          function endSliderDrag(sliderId) {
              // 清除超时
              if (sliderTimeouts[sliderId]) {
                  clearTimeout(sliderTimeouts[sliderId]);
                  delete sliderTimeouts[sliderId];
              }
              
              // 从拖动集合中移除
              draggingSliders.delete(sliderId);
              
              // 延迟恢复更新，确保change事件完成
              setTimeout(() => {
                  isDraggingSlider = draggingSliders.size > 0;
                  // log(`Ended dragging slider: ${sliderId}, total dragging: ${draggingSliders.size}`);
              }, 100);
          }

          // 设置Brightness - 发送B9命令第13字节
          async function setBrightness(brightness) {
              // 验证亮度范围
              const brightnessValue = parseInt(brightness);
              if (brightnessValue < 0 || brightnessValue > 100) {
                  log(`Error: Brightness ${brightnessValue} is out of range (0-100)`);
                  // 恢复之前的值
                  document.getElementById('brightness').value = currentB9State.byte13;
                  updateBrightnessDisplay(currentB9State.byte13);
                  return;
              }

              // 调用通用B9命令函数，只更新Brightness（第13字节）
              await sendB9Command(
                  { byte13: brightnessValue },
                  `Brightness set to ${brightnessValue}`
              );
          }

          // 切换模式 - 发送B5命令格式：B5 05 01 mode B5
          async function switchMode() {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              try {
                  // 循环切换模式：Steady (A1) → Ascent (B1) → Descent (C1) → Valley (D1) → Hill (E1) → Steady (A1)
                  let newMode;
                  switch (currentMode) {
                      case 0xA1: // Steady -> Ascent
                          newMode = 0xB1;
                          break;
                      case 0xB1: // Ascent -> Descent
                          newMode = 0xC1;
                          break;
                      case 0xC1: // Descent -> Valley
                          newMode = 0xD1;
                          break;
                      case 0xD1: // Valley -> Hill
                          newMode = 0xE1;
                          break;
                      case 0xE1: // Hill -> Steady
                          newMode = 0xA1;
                          break;
                      default: // 默认为 Steady
                          newMode = 0xA1;
                          break;
                  }

                  // 构造B5命令数据包：B5 05 00 mode B5 (preset 0 = 全局Mode Control)
                  const modeCommand = new Uint8Array(5);
                  modeCommand[0] = 0xB5;    // 起始标识
                  modeCommand[1] = 0x05;    // 数据长度
                  modeCommand[2] = 0x00;    // preset 0 (全局Mode Control)
                  modeCommand[3] = newMode; // 模式值
                  modeCommand[4] = 0xB5;    // 结束标识

                  // 发送模式切换命令
                  await characteristic.writeValue(modeCommand);
                  
                  const modeName = MODE_TYPES[newMode];
                  const packetHex = Array.from(modeCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  
                  log(`✓ Mode switch command sent: ${modeName} (0x${newMode.toString(16).padStart(2, '0')})`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 临时更新显示（等待设备notify确认）
                  updateModeDisplay(newMode, modeName);
                  currentMode = newMode;
                  
                  showNotification(`模式切换为 ${modeName}`, 'success', 2000);
                  
              } catch (error) {
                  log(`✗ Failed to switch mode: ${error.message}`);
                  showNotification(`模式切换失败: ${error.message}`, 'error');
              }
          }

          // 更新模式显示
          function updateModeDisplay(mode, modeName) {
              document.getElementById('currentModeDisplay').textContent = modeName;
              
              // 更新模式序列显示，高亮当前模式
              let sequenceText = '';
              const modes = ['Steady', 'Ascent', 'Descent', 'Valley', 'Hill'];
              const currentModeName = modeName.split(' ')[0]; // 移除可能的 "(0x...)" 部分
              
              modes.forEach((name, index) => {
                  if (name === currentModeName) {
                      sequenceText += `<strong style="color: var(--primary-color);">${name}</strong>`;
                  } else {
                      sequenceText += name;
                  }
                  
                  if (index < modes.length - 1) {
                      sequenceText += ' → ';
                  }
              });
              
              document.getElementById('modeSequence').innerHTML = sequenceText;
          }

          // 切换Haptic反馈 - 发送B9命令第11字节
          async function toggleHaptic() {
              // 切换当前状态
              const newHapticState = currentB9State.byte11 === 0xAA ? 0x00 : 0xAA;
              const isEnabled = newHapticState === 0xAA;
              
              // 调用通用B9命令函数，只更新Haptic状态（第11字节）
              await sendB9Command(
                  { byte11: newHapticState },
                  `Haptic feedback ${isEnabled ? 'enabled' : 'disabled'}`
              );
              
              // 立即更新按钮显示
              updateHapticButton(isEnabled);
              
              showNotification(`触觉反馈已${isEnabled ? '开启' : '关闭'}`, 'success', 2000);
          }

          // Session Boost - 点击式操作：每次点击发送递增的数值
          async function toggleBoost() {
              try {
                  // 每次点击递增byte12的值
                  currentB9State.byte12 += 1;
                  
                  // 发送递增的值
                  await sendB9Command(
                      { byte12: currentB9State.byte12 },
                      `Session boost value: ${currentB9State.byte12}`
                  );
                  
                  // 更新按钮显示当前值
                  updateBoostButton(currentB9State.byte12);
                  showNotification(`boost值: ${currentB9State.byte12}`, 'warning', 1500);
                  
              } catch (error) {
                  log(`✗ Failed to send boost value: ${error.message}`);
                  showNotification('boost发送失败', 'error');
              }
          }

          // 更新Haptic按钮显示
          function updateHapticButton(isEnabled) {
              const hapticBtn = document.getElementById('hapticBtn');
              if (isEnabled) {
                  hapticBtn.textContent = 'On';
                  hapticBtn.className = 'btn btn-success';
                  hapticBtn.style.minWidth = '80px';
                  hapticBtn.style.padding = '6px 12px';
                  hapticBtn.style.fontSize = '0.8rem';
              } else {
                  hapticBtn.textContent = 'Off';
                  hapticBtn.className = 'btn btn-secondary';
                  hapticBtn.style.minWidth = '80px';
                  hapticBtn.style.padding = '6px 12px';
                  hapticBtn.style.fontSize = '0.8rem';
              }
          }

          // 更新Boost按钮显示
          function updateBoostButton(value) {
              const boostBtn = document.getElementById('boostBtn');
              if (typeof value === 'number' && value > 0) {
                  boostBtn.textContent = `Boost(${value})`;
                  boostBtn.className = 'btn btn-warning'; // 使用警告色表示boost有值
                  boostBtn.style.minWidth = '80px';
                  boostBtn.style.padding = '6px 12px';
                  boostBtn.style.fontSize = '0.8rem';
              } else {
                  boostBtn.textContent = 'Boost';
                  boostBtn.className = 'btn btn-secondary';
                  boostBtn.style.minWidth = '80px';
                  boostBtn.style.padding = '6px 12px';
                  boostBtn.style.fontSize = '0.8rem';
              }
          }

          // 切换CleaningAssist状态 - 发送C6命令格式：C6 04 AA/00 C6
          async function toggleCleaningAssist() {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              try {
                  // 切换状态
                  cleaningAssistEnabled = !cleaningAssistEnabled;
                  const commandValue = cleaningAssistEnabled ? 0xAA : 0x00;
                  
                  // 构造C6命令数据包：C6 04 AA/00 C6
                  const cleaningCommand = new Uint8Array(4);
                  cleaningCommand[0] = 0xC6;        // 起始标识
                  cleaningCommand[1] = 0x04;        // 数据长度
                  cleaningCommand[2] = commandValue; // AA=开启, 00=关闭
                  cleaningCommand[3] = 0xC6;        // 结束标识

                  // 发送清洁助手命令
                  await characteristic.writeValue(cleaningCommand);
                  
                  const packetHex = Array.from(cleaningCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  const action = cleaningAssistEnabled ? 'enabled' : 'disabled';
                  
                  log(`✓ Cleaning Assist ${action}`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 更新按钮显示
                  updateCleaningAssistButton(cleaningAssistEnabled);
                  
                  showNotification(`清洁助手已${cleaningAssistEnabled ? '开启' : '关闭'}`, 'success', 2000);
                  
              } catch (error) {
                  // 发送失败时恢复状态
                  cleaningAssistEnabled = !cleaningAssistEnabled;
                  log(`✗ Failed to toggle Cleaning Assist: ${error.message}`);
                  showNotification(`清洁助手操作失败: ${error.message}`, 'error');
              }
          }

          // 更新CleaningAssist按钮显示
          function updateCleaningAssistButton(isEnabled) {
              const cleaningBtn = document.getElementById('cleaningAssistBtn');
              if (isEnabled) {
                  cleaningBtn.textContent = 'Stop Cleaning';
                  cleaningBtn.className = 'btn btn-warning';
                  cleaningBtn.style.minWidth = '150px';
                  // 更新图标
                  cleaningBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Cleaning';
              } else {
                  cleaningBtn.textContent = 'Cleaning Assist';
                  cleaningBtn.className = 'btn btn-secondary';
                  cleaningBtn.style.minWidth = '150px';
                  // 更新图标
                  cleaningBtn.innerHTML = '<i class="fas fa-broom"></i> Cleaning Assist';
              }
          }

          // 更新当前preset对应的模式显示
          function updateCurrentPresetModeDisplay(preset) {
              const currentPresetModeElement = document.getElementById('currentPresetMode');
              if (currentPresetModeElement && preset >= 1 && preset <= 5) {
                  const presetMode = presetModes[preset];
                  const modeName = MODE_TYPES[presetMode] || 'Unknown';
                  currentPresetModeElement.textContent = modeName;
              }
          }

          // ==================== Preset Hold Time 控制 ====================
          
          // 更新Preset Hold Time显示值（实时）
          function updatePresetHoldTimeDisplay(preset, value) {
              document.getElementById(`presetHoldTimeDisplay${preset}`).textContent = value + 's';
          }

          // 设置Preset Hold Time - 发送B7命令格式：B7 06 preset time_high time_low B7
          async function setPresetHoldTime(preset, seconds) {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              // 验证时间范围
              const holdTime = parseInt(seconds);
              if (holdTime < 10 || holdTime > 90) {
                  log(`Error: Preset ${preset} Hold Time ${holdTime} is out of range (10-90 seconds)`);
                  // 恢复之前的值
                  document.getElementById(`presetHoldTime${preset}`).value = presetHoldTimes[preset];
                  updatePresetHoldTimeDisplay(preset, presetHoldTimes[preset]);
                  return;
              }

              try {
                  // 构造B7命令数据包：B7 06 preset holdTime(high) holdTime(low) B7
                  const holdTimeCommand = new Uint8Array(6);
                  holdTimeCommand[0] = 0xB7;                      // 起始标识
                  holdTimeCommand[1] = 0x06;                      // 数据长度
                  holdTimeCommand[2] = preset;                    // preset (1-5)
                  holdTimeCommand[3] = (holdTime >> 8) & 0xFF;    // holdTime高字节
                  holdTimeCommand[4] = holdTime & 0xFF;           // holdTime低字节
                  holdTimeCommand[5] = 0xB7;                      // 结束标识

                  // 发送Preset Hold Time设置命令
                  await characteristic.writeValue(holdTimeCommand);
                  
                  const packetHex = Array.from(holdTimeCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  
                  log(`✓ Preset ${preset} Hold Time set to ${holdTime} seconds`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 更新本地存储
                  presetHoldTimes[preset] = holdTime;
                  
                  showNotification(`预设${preset}保持时间设置为${holdTime}秒`, 'success', 2000);
                  
              } catch (error) {
                  log(`✗ Failed to set Preset ${preset} Hold Time: ${error.message}`);
                  showNotification(`预设${preset}保持时间设置失败: ${error.message}`, 'error');
              }
          }

          // ==================== Preset Mode 控制 ====================
          
          // 获取Custom setting中最后一个非0点的时间值
          function getLastNonZeroTimeFromCustom() {
              const timeInputs = document.querySelectorAll('#customConfigCard .custom-time');
              let lastNonZeroTime = 30; // 默认值
              
              // 从后往前查找最后一个非0的时间值
              for (let i = timeInputs.length - 1; i >= 1; i--) { // 从point8到point2
                  const timeValue = parseInt(timeInputs[i].value) || 0;
                  if (timeValue > 0) {
                      lastNonZeroTime = timeValue;
                      break;
                  }
              }
              
              return lastNonZeroTime;
          }

          // 设置Preset Mode - 发送B5命令格式：B5 05 preset mode B5
          async function setPresetMode(preset, modeValue) {
              if (!characteristic) {
                  log('Error: Device not connected');
                  return;
              }

              try {
                  // 解析十六进制模式值
                  const mode = parseInt(modeValue, 16);
                  const modeName = MODE_TYPES[mode] || 'Unknown';
                  
                  // 验证模式值
                  if (!(mode in MODE_TYPES)) {
                      log(`Error: Invalid mode value ${modeValue} for preset ${preset}`);
                      return;
                  }

                  // 如果模式是Custom(0xF1)，自动设置Hold Time为Custom setting中最后一个非0点的时间值
                  if (mode === 0xF1) {
                      const customHoldTime = getLastNonZeroTimeFromCustom();
                      
                      // 更新UI滑块
                      const holdTimeSlider = document.getElementById(`presetHoldTime${preset}`);
                      if (holdTimeSlider) {
                          holdTimeSlider.value = customHoldTime;
                          updatePresetHoldTimeDisplay(preset, customHoldTime);
                          presetHoldTimes[preset] = customHoldTime;
                      }
                      
                      // 发送Hold Time设置命令
                      await setPresetHoldTime(preset, customHoldTime);
                      
                      log(`✓ Auto-set Preset ${preset} Hold Time to ${customHoldTime}s (last non-zero custom time)`);
                      showNotification(`预设${preset}保持时间自动设置为${customHoldTime}秒（基于Custom配置）`, 'info', 3000);
                  }

                  // 构造B5命令数据包：B5 05 preset mode B5
                  const modeCommand = new Uint8Array(5);
                  modeCommand[0] = 0xB5;    // 起始标识
                  modeCommand[1] = 0x05;    // 数据长度
                  modeCommand[2] = preset;  // preset (1-5)
                  modeCommand[3] = mode;    // 模式值
                  modeCommand[4] = 0xB5;    // 结束标识

                  // 发送Preset Mode设置命令
                  await characteristic.writeValue(modeCommand);
                  
                  const packetHex = Array.from(modeCommand).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                  
                  log(`✓ Preset ${preset} Mode set to ${modeName} (${modeValue})`);
                  log(`  Packet data: ${packetHex}`);
                  
                  // 更新本地存储
                  presetModes[preset] = mode;
                  
                  showNotification(`预设${preset}模式设置为${modeName}`, 'success', 2000);
                  
              } catch (error) {
                  log(`✗ Failed to set Preset ${preset} Mode: ${error.message}`);
                  showNotification(`预设${preset}模式设置失败: ${error.message}`, 'error');
              }
          }

          // ==================== 数据接收处理 ====================
          
          // 处理A7格式的Preset Hold Time响应数据包
          function handlePresetHoldTimeData(data) {
              if (data.length !== 6 || data[0] !== 0xA7 || data[5] !== 0xA7) {
                  log(`Invalid A7 preset hold time packet format`);
                  return;
              }
              
              const preset = data[2];
              const holdTime = (data[3] << 8) | data[4];
              
              // 验证preset范围
              if (preset < 1 || preset > 5) {
                  log(`Invalid preset index in A7 packet: ${preset}`);
                  return;
              }
              
              // 更新本地存储和UI（只在不拖动时更新）
              presetHoldTimes[preset] = holdTime;
              if (!draggingSliders.has(`presetHoldTime${preset}`)) {
                  document.getElementById(`presetHoldTime${preset}`).value = holdTime;
                  updatePresetHoldTimeDisplay(preset, holdTime);
              }
              
              log(`Received preset ${preset} hold time: ${holdTime} seconds`);
          }

          // 处理A5格式的Preset Mode响应数据包
          function handlePresetModeData(data) {
              if (data.length !== 5 || data[0] !== 0xA5 || data[4] !== 0xA5) {
                  log(`Invalid A5 preset mode packet format`);
                  return;
              }
              
              const preset = data[2];
              const mode = data[3];
              const modeName = MODE_TYPES[mode] || `Unknown (0x${mode.toString(16).padStart(2, '0')})`;
              
              // 验证preset范围
              if (preset < 1 || preset > 5) {
                  log(`Invalid preset index in A5 packet: ${preset}`);
                  return;
              }
              
              // 更新本地存储和UI
              presetModes[preset] = mode;
              const selectElement = document.getElementById(`presetMode${preset}`);
              if (selectElement) {
                  const hexValue = '0x' + mode.toString(16).padStart(2, '0').toUpperCase();
                  selectElement.value = hexValue;
              }
              
              // 如果这是当前活动的preset，更新状态监控中的显示
              if (preset === currentPreset) {
                  updateCurrentPresetModeDisplay(preset);
              }
              
              log(`Received preset ${preset} mode: ${modeName} (0x${mode.toString(16).padStart(2, '0')})`);
          }

        // 检查固件版本并返回状态
        function checkFirmwareVersion(softwareRevision) {
            if (!softwareRevision || softwareRevision === '--') {
                return { needsUpdate: false, statusText: 'Unknown version', isHighlight: false };
            }

            // 解析软件版本格式：SW2-YYMMDD-XXX
            const versionMatch = softwareRevision.match(/SW2-(\d{6})/);
            if (!versionMatch) {
                return { needsUpdate: false, statusText: 'Unknown format', isHighlight: false };
            }

            const currentDate = versionMatch[1]; // YYMMDD格式
            const targetDate = '250626'; // SW2-250626

            if (currentDate < targetDate) {
                return { 
                    needsUpdate: true, 
                    statusText: 'New firmware available', 
                    isHighlight: true 
                };
            } else if (currentDate === targetDate) {
                return { 
                    needsUpdate: false, 
                    statusText: 'Newest firmware', 
                    isHighlight: false 
                };
            } else {
                return { 
                    needsUpdate: false, 
                    statusText: 'Newer than target', 
                    isHighlight: false 
                };
            }
        }

        // 更新固件状态显示
        function updateFirmwareStatus(softwareRevision) {
            const statusContainer = document.getElementById('firmwareStatusContainer');
            const statusText = document.getElementById('firmwareStatusText');
            const updateBtn = document.getElementById('updateFirmwareBtn');

            const firmwareStatus = checkFirmwareVersion(softwareRevision);

            if (firmwareStatus.statusText !== 'Unknown version') {
                statusContainer.style.display = 'block';
                statusText.textContent = firmwareStatus.statusText;

                if (firmwareStatus.isHighlight) {
                    // 高亮显示：橙色背景
                    statusText.style.color = '#ff6b35';
                    statusText.style.backgroundColor = 'rgba(255, 107, 53, 0.1)';
                    statusText.style.padding = '2px 6px';
                    statusText.style.borderRadius = '4px';
                    statusText.style.border = '1px solid rgba(255, 107, 53, 0.3)';
                    
                    // 按钮也高亮
                    updateBtn.classList.remove('btn-warning');
                    updateBtn.classList.add('btn-danger');
                    updateBtn.style.animation = 'pulse 2s infinite';
                } else {
                    // 普通显示：绿色
                    statusText.style.color = '#28a745';
                    statusText.style.backgroundColor = 'rgba(40, 167, 69, 0.1)';
                    statusText.style.padding = '2px 6px';
                    statusText.style.borderRadius = '4px';
                    statusText.style.border = '1px solid rgba(40, 167, 69, 0.3)';
                    
                    // 按钮普通样式
                    updateBtn.classList.remove('btn-danger');
                    updateBtn.classList.add('btn-warning');
                    updateBtn.style.animation = 'none';
                }
            } else {
                statusContainer.style.display = 'none';
            }

            log(`Firmware status: ${firmwareStatus.statusText} (Highlight: ${firmwareStatus.isHighlight})`);
        }

        // 只读取software revision、manufacturer和hardware version
        async function readSoftwareAndManufacturer(server) {
            let softwareRevision = '--';
            let manufacturerName = '--';
            let hardwareVersion = '--';
            try {
                const deviceInfoService = await server.getPrimaryService(DEVICE_INFO_SERVICE_UUID);
                // Software Revision
                try {
                    const swCharacteristic = await deviceInfoService.getCharacteristic(SOFTWARE_REVISION_UUID);
                    const swValue = await swCharacteristic.readValue();
                    softwareRevision = new TextDecoder().decode(swValue);
                    log(`Software Revision: ${softwareRevision}`);
                } catch (error) {
                    log(`Failed to read Software Revision: ${error.message}`);
                }
                // Manufacturer Name
                try {
                    const mfgCharacteristic = await deviceInfoService.getCharacteristic(MANUFACTURER_NAME_UUID);
                    const mfgValue = await mfgCharacteristic.readValue();
                    manufacturerName = new TextDecoder().decode(mfgValue);
                    log(`Manufacturer Name: ${manufacturerName}`);
                } catch (error) {
                    log(`Failed to read Manufacturer Name: ${error.message}`);
                }
                // Hardware Version
                try {
                    const hwCharacteristic = await deviceInfoService.getCharacteristic(HARDWARE_VERSION_UUID);
                    const hwValue = await hwCharacteristic.readValue();
                    hardwareVersion = new TextDecoder().decode(hwValue);
                    log(`Hardware Version: ${hardwareVersion}`);
                } catch (error) {
                    log(`Failed to read Hardware Version: ${error.message}`);
                }
            } catch (error) {
                log(`Failed to get Device Info Service: ${error.message}`);
            }
            // 更新UI
            document.getElementById('softwareRevision').textContent = softwareRevision || '--';
            document.getElementById('manufacturerName').textContent = manufacturerName || '--';
            document.getElementById('hardwareVersion').textContent = hardwareVersion || '--';
            
            // 检查并更新固件状态
            updateFirmwareStatus(softwareRevision);
        }

        // ========== Custom参数配置相关 ==========
        
                 // 验证自定义时间点的递增逻辑
         function validateCustomTime(input, pointIndex) {
             const timeInputs = document.querySelectorAll('#customConfigCard .custom-time');
             const currentValue = parseInt(input.value) || 0;
             
             // 获取前一个点的时间值
             let previousValue = 0;
             if (pointIndex > 1) {
                 previousValue = parseInt(timeInputs[pointIndex - 2].value) || 0;
             }
             
             let isValid = true;
             let errorMessage = '';
             
             // 验证规则
             if (pointIndex === 2) {
                 // point2必须大于0
                 if (currentValue <= 0) {
                     isValid = false;
                     errorMessage = 'Point2时间必须大于0';
                 }
             } else {
                 // point3-8：必须大于前一个点或者为0
                 if (currentValue !== 0 && currentValue <= previousValue) {
                     isValid = false;
                     errorMessage = `Point${pointIndex}时间必须大于Point${pointIndex-1}(${previousValue}s)或者为0`;
                 }
             }
             
             // 设置输入框样式
             if (isValid) {
                 input.style.borderColor = '';
                 input.style.backgroundColor = '';
                 input.title = '';
                 
                 // 如果验证通过，更新所有Custom模式preset的Hold Time
                 updateCustomModeHoldTimes();
             } else {
                 input.style.borderColor = '#dc3545';
                 input.style.backgroundColor = '#f8d7da';
                 input.title = errorMessage;
                 
                 // 显示错误提示
                 showNotification(errorMessage, 'warning', 3000);
                 
                 // 恢复到有效值
                 setTimeout(() => {
                     if (pointIndex === 2) {
                         input.value = Math.max(1, previousValue + 1);
                     } else {
                         input.value = currentValue === 0 ? 0 : Math.max(previousValue + 1, currentValue);
                     }
                     validateCustomTime(input, pointIndex);
                 }, 1500);
             }
             
             // 验证后续点的时间值
             validateSubsequentPoints(pointIndex);
         }
        
                 // 验证后续点的时间值（当前点改变时，检查后续点是否还有效）
         function validateSubsequentPoints(changedPointIndex) {
             const timeInputs = document.querySelectorAll('#customConfigCard .custom-time');
             
             for (let i = changedPointIndex; i < timeInputs.length; i++) {
                 const input = timeInputs[i];
                 if (input.readOnly) continue; // 跳过point1
                 
                 validateCustomTime(input, i + 1);
             }
         }
         
         // 验证所有时间点设置是否正确
         function validateAllCustomTimes() {
             const timeInputs = document.querySelectorAll('#customConfigCard .custom-time');
             let allValid = true;
             
             for (let i = 1; i < timeInputs.length; i++) { // 从point2开始
                 const input = timeInputs[i];
                 const currentValue = parseInt(input.value) || 0;
                 const previousValue = i === 1 ? 0 : parseInt(timeInputs[i - 1].value) || 0;
                 
                 if (i === 1) {
                     // point2必须大于0
                     if (currentValue <= 0) {
                         allValid = false;
                         break;
                     }
                 } else {
                     // point3-8：必须大于前一个点或者为0
                     if (currentValue !== 0 && currentValue <= previousValue) {
                         allValid = false;
                         break;
                     }
                 }
             }
             
             return allValid;
         }
        
        function getCustomProfileFromUI() {
            const temps = Array.from(document.querySelectorAll('#customConfigCard .custom-temp')).map(input => parseInt(input.value) || 0);
            const times = Array.from(document.querySelectorAll('#customConfigCard .custom-time')).map((input, index) => {
                // point1的时间固定为0
                if (index === 0) return 0;
                return parseInt(input.value) || 0;
            });
            return { temp: temps, time: times };
        }
        // 更新所有设置为Custom模式的preset的Hold Time
        function updateCustomModeHoldTimes() {
            const customHoldTime = getLastNonZeroTimeFromCustom();
            
            for (let i = 1; i <= 5; i++) {
                const modeSelect = document.getElementById(`presetMode${i}`);
                if (modeSelect && modeSelect.value === '0xF1') { // Custom模式
                    const holdTimeSlider = document.getElementById(`presetHoldTime${i}`);
                    if (holdTimeSlider) {
                        holdTimeSlider.value = customHoldTime;
                        updatePresetHoldTimeDisplay(i, customHoldTime);
                        presetHoldTimes[i] = customHoldTime;
                        
                        // 发送更新的Hold Time到设备
                        setPresetHoldTime(i, customHoldTime);
                    }
                }
            }
            
            if (customHoldTime > 30) { // 只有当时间不是默认值时才显示通知
                showNotification(`已更新所有Custom模式preset的保持时间为${customHoldTime}秒`, 'info', 2000);
            }
        }

        async function sendCustomProfile() {
            if (!characteristic) {
                log('Error: Device not connected');
                showNotification('设备未连接', 'error');
                return;
            }
            
            // 发送前进行最终验证
            if (!validateAllCustomTimes()) {
                showNotification('请先修正时间点设置错误', 'error');
                return;
            }
            
            // 更新所有Custom模式preset的Hold Time
            updateCustomModeHoldTimes();
            
            const profile = getCustomProfileFromUI();
            // 组包并发送两包（ba/bb头尾）
            for (let index = 0; index < 2; index++) {
                let ble_tx_buff = new Uint8Array(15);
                let ble_tx_len = 15;
                if (index === 0) {
                    ble_tx_buff[0] = 0xba;
                    ble_tx_buff[1] = ble_tx_len;
                    ble_tx_buff[2] = profile.temp[0] >> 8;
                    ble_tx_buff[3] = profile.temp[0] & 0xff;
                    ble_tx_buff[4] = profile.time[0];
                    ble_tx_buff[5] = profile.temp[1] >> 8;
                    ble_tx_buff[6] = profile.temp[1] & 0xff;
                    ble_tx_buff[7] = profile.time[1];
                    ble_tx_buff[8] = profile.temp[2] >> 8;
                    ble_tx_buff[9] = profile.temp[2] & 0xff;
                    ble_tx_buff[10] = profile.time[2];
                    ble_tx_buff[11] = profile.temp[3] >> 8;
                    ble_tx_buff[12] = profile.temp[3] & 0xff;
                    ble_tx_buff[13] = profile.time[3];
                    ble_tx_buff[14] = 0xba;
                } else {
                    ble_tx_buff[0] = 0xbb;
                    ble_tx_buff[1] = ble_tx_len;
                    ble_tx_buff[2] = profile.temp[4] >> 8;
                    ble_tx_buff[3] = profile.temp[4] & 0xff;
                    ble_tx_buff[4] = profile.time[4];
                    ble_tx_buff[5] = profile.temp[5] >> 8;
                    ble_tx_buff[6] = profile.temp[5] & 0xff;
                    ble_tx_buff[7] = profile.time[5];
                    ble_tx_buff[8] = profile.temp[6] >> 8;
                    ble_tx_buff[9] = profile.temp[6] & 0xff;
                    ble_tx_buff[10] = profile.time[6];
                    ble_tx_buff[11] = profile.temp[7] >> 8;
                    ble_tx_buff[12] = profile.temp[7] & 0xff;
                    ble_tx_buff[13] = profile.time[7];
                    ble_tx_buff[14] = 0xbb;
                }
                try {
                    await characteristic.writeValue(ble_tx_buff);
                    log(`✓ Custom参数包${index+1}已发送(ba/bb): [${Array.from(ble_tx_buff).map(b=>b.toString(16).padStart(2,'0')).join(' ')}]`);
                } catch (e) {
                    log(`✗ Custom参数包${index+1}发送失败: ${e.message}`);
                    showNotification(`自定义参数包${index+1}发送失败`, 'error');
                    return;
                }
            }
            showNotification('自定义参数全部发送成功', 'success');
        }
        document.getElementById('sendCustomProfileBtn').onclick = sendCustomProfile;

        // 新增：自定义参数包解析
        function handleCustomProfileData(data) {
            let group = (data[0] === 0xaa) ? 0 : 1;
            let temps = [];
            let times = [];
            for(let i=0; i<4; i++) {
                let temp = (data[2+i*3] << 8) | data[3+i*3];
                let time = data[4+i*3];
                temps.push(temp);
                times.push(time);
            }
            
            // 更新UI输入框
            for(let i=0; i<4; i++) {
                let idx = group*4 + i;
                const tempInputs = document.querySelectorAll('#customConfigCard .custom-temp');
                const timeInputs = document.querySelectorAll('#customConfigCard .custom-time');
                if (tempInputs[idx]) tempInputs[idx].value = temps[i];
                if (timeInputs[idx]) {
                    // point1的时间固定为0，不更新
                    if (idx !== 0) {
                        timeInputs[idx].value = times[i];
                    }
                }
            }
            
            log(`收到自定义参数包${group+1}：温度=[${temps.join(', ')}]，时间=[${times.join(', ')}]`);
            showNotification(`收到自定义参数包${group+1}已同步到UI`,'info');
        }
    </script>
</body>
</html> 