<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è“ç‰™è®¾å¤‡è¿æ¥æ§åˆ¶å°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.7);
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            color: #444;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }
        
        .input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .log-area {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .device-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .device-info p {
            margin: 5px 0;
            color: #666;
        }
        
        .hex-display {
            background: #000;
            color: #0ff;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            margin: 5px 0;
        }
        
        .device-data-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .data-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .data-label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        
        .data-value {
            color: #333;
            font-family: monospace;
            font-size: 14px;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 60px;
            text-align: center;
        }
        
        .data-value.clickable {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }
        
        .data-value.clickable:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }
        
        .temp-control {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .temp-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        .temp-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .temp-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .temp-display {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”· è“ç‰™è®¾å¤‡æ§åˆ¶å°</h1>
        
        <div class="section">
            <h2>ğŸ“¡ è®¾å¤‡è¿æ¥</h2>
            <button id="scanBtn" class="btn">æ‰«æå¹¶è¿æ¥è®¾å¤‡</button>
            <button id="disconnectBtn" class="btn" disabled>æ–­å¼€è¿æ¥</button>
            <div id="status" class="status disconnected">çŠ¶æ€: æœªè¿æ¥</div>
            <div id="deviceInfo" class="device-info" style="display: none;">
                <p><strong>è®¾å¤‡åç§°:</strong> <span id="deviceName">-</span></p>
                <p><strong>è®¾å¤‡ID:</strong> <span id="deviceId">-</span></p>
                <p><strong>è¿æ¥çŠ¶æ€:</strong> <span id="connectionState">-</span></p>
            </div>
        </div>
        
        
        <div class="section">
            <h2>ğŸ“Š è®¾å¤‡ä¿¡æ¯</h2>
            <div id="deviceDataCard" class="device-data-card" style="display: none;">
                <div class="data-grid">
                    <div class="data-item">
                        <span class="data-label">é›¾åŒ–å™¨ç±»å‹:</span>
                        <span id="atomizerType" class="data-value clickable" title="ç‚¹å‡»åˆ‡æ¢é›¾åŒ–å™¨ç±»å‹">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">æ¸©åº¦å•ä½:</span>
                        <span id="tempUnit" class="data-value clickable" title="ç‚¹å‡»åˆ‡æ¢æ¸©åº¦å•ä½">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">ç”µæ± ç”µé‡:</span>
                        <span id="batteryLevel" class="data-value">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">å½“å‰ç”µå‹:</span>
                        <div class="temp-control">
                            <input type="range" id="voltageSlider" min="20" max="40" step="1" value="28" class="temp-slider">
                            <span id="currentVoltage" class="data-value temp-display">2.8V</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <span class="data-label">å½“å‰æ¸©åº¦(åæ°):</span>
                        <div class="temp-control">
                            <input type="range" id="tempSlider" min="300" max="800" step="25" value="500" class="temp-slider">
                            <span id="currentTempF" class="data-value temp-display">500Â°F</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <span class="data-label">å½“å‰æ¸©åº¦(æ‘„æ°):</span>
                        <div class="temp-control">
                            <input type="range" id="tempCSlider" min="149" max="427" step="1" value="260" class="temp-slider">
                            <span id="currentTempC" class="data-value temp-display">260Â°C</span>
                        </div>
                    </div>
                    <div class="data-item">
                        <span class="data-label">å½“å‰é˜»å€¼:</span>
                        <span id="currentResistance" class="data-value">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">å½“å‰åŠŸç‡:</span>
                        <span id="currentPower" class="data-value">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Puffè®¡æ•°1:</span>
                        <span id="puffCount1" class="data-value">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Puffè®¡æ•°2:</span>
                        <span id="puffCount2" class="data-value">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ”„ OTA å›ºä»¶æ›´æ–°</h2>
            <button id="startOTABtn" class="btn" style="margin-bottom: 10px;" disabled>å¼€å§‹ OTA æ›´æ–°</button>
            <div id="otaStatus" class="status disconnected">OTAçŠ¶æ€: ç­‰å¾…è¿æ¥è®¾å¤‡</div>
            <div id="otaProgress" style="margin: 10px 0; display: none;">
                <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden;">
                    <div id="otaProgressBar" style="background: linear-gradient(45deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="otaProgressText" style="text-align: center; margin-top: 5px; font-size: 14px; color: #666;">0%</div>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“¥ æ¥æ”¶æ•°æ®æ—¥å¿—</h2>
            <button id="clearLogBtn" class="btn" style="margin-bottom: 10px;">æ¸…ç©ºæ—¥å¿—</button>
            <div id="logArea" class="log-area">ç­‰å¾…è¿æ¥è®¾å¤‡...</div>
        </div>
    </div>

    <script>
        // è“ç‰™æœåŠ¡å’Œç‰¹å¾UUID
        const SERVICE_UUID = '00010203-0405-0607-0809-0a0b0c0d1910';
        const RX_CHARACTERISTIC_UUID = '00010203-0405-0607-0809-0a0b0c0d2b10'; // æ¥æ”¶é€šçŸ¥
        const TX_CHARACTERISTIC_UUID = '00010203-0405-0607-0809-0a0b0c0d2b11'; // å‘é€æ•°æ®
        
        // OTA æœåŠ¡å’Œç‰¹å¾UUID
        const OTA_SERVICE_UUID = '00010203-0405-0607-0809-0a0b0c0d1912';
        const OTA_CHARACTERISTIC_UUID = '00010203-0405-0607-0809-0a0b0c0d2b12';

        // å…¨å±€å˜é‡
        let bluetoothDevice;
        let bluetoothServer;
        let service;
        let rxCharacteristic;
        let txCharacteristic;
        
        // OTA ç›¸å…³å˜é‡
        let otaService;
        let otaCharacteristic;
        let firmwareArray = "";
        let otaStartTime = 0;
        let otaBlockCount = 0;
        let otaConnectTrys = 0;
        
        // è®¾å¤‡çŠ¶æ€å˜é‡
        let currentAtomizerMode = 0xa0; // é»˜è®¤æ¸©åº¦æ¨¡å¼
        let currentTempUnit = 0x11; // é»˜è®¤åæ°åº¦
        let currentVoltage = 40;
        let current_TempF = 800;
        let current_TempC = 426;
        
        // æ¸©åº¦æ»‘å—äº‹ä»¶å¤„ç†
        const tempSlider = document.getElementById('tempSlider');
        const voltageSlider = document.getElementById('voltageSlider');
        const tempCSlider = document.getElementById('tempCSlider');
        const currentTempFDisplay = document.getElementById('currentTempF');
        const currentTempCDisplay = document.getElementById('currentTempC');
        const currentVoltageDisplay = document.getElementById('currentVoltage');
        
        // åæ°åº¦è½¬æ‘„æ°åº¦
        function fahrenheitToCelsius(fahrenheit) {
            return Math.round((fahrenheit - 32) * 5 / 9);
        }
        
        // æ‘„æ°åº¦è½¬åæ°åº¦
        function celsiusToFahrenheit(celsius) {
            return Math.round(celsius * 9 / 5 + 32);
        }
        
        // æ›´æ–°æ‰€æœ‰æ˜¾ç¤ºçš„å‡½æ•°
         function updateAllDisplays(tempF, tempC, voltage) {
             current_TempF = tempF;
             current_TempC = tempC;
             currentVoltage = voltage;
             
             currentTempFDisplay.textContent = `${tempF}Â°F`;
             currentTempCDisplay.textContent = `${tempC}Â°C`;
             currentVoltageDisplay.textContent = `${(voltage/10).toFixed(1)}V`;
             
             // æ›´æ–°æ»‘å—ä½ç½®ï¼ˆé¿å…å¾ªç¯è§¦å‘ï¼‰
             tempSlider.value = tempF;
             tempCSlider.value = tempC;
             voltageSlider.value = voltage;
             
             // å¦‚æœè®¾å¤‡å·²è¿æ¥ï¼Œå‘é€æ¸©åº¦è®¾ç½®å‘½ä»¤
             if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                 sendTemperatureSetting(tempF, tempC);
             }
         }
         
         // åæ°æ¸©åº¦æ»‘å—å˜åŒ–äº‹ä»¶
         tempSlider.addEventListener('input', function() {
             const tempF = parseInt(this.value);
             const tempC = fahrenheitToCelsius(tempF);
             const voltage = Math.round(20 + (tempF - 300) / 25);
             
             updateAllDisplays(tempF, tempC, voltage);
         });
         
         // ç”µå‹æ»‘å—å˜åŒ–äº‹ä»¶
         voltageSlider.addEventListener('input', function() {
             const voltage = parseInt(this.value);
             const tempF = (voltage - 20) * 25 + 300;
             const tempC = fahrenheitToCelsius(tempF);
             
             updateAllDisplays(tempF, tempC, voltage);
         });
         
         // æ‘„æ°æ¸©åº¦æ»‘å—å˜åŒ–äº‹ä»¶
          tempCSlider.addEventListener('input', function() {
              const tempC = parseInt(this.value);
              // å…ˆè½¬æ¢ä¸ºåæ°åº¦
              let tempF = celsiusToFahrenheit(tempC);
              // æŒ‰ç…§åæ°åº¦25æ­¥è¿›è°ƒæ•´
              tempF = Math.round((tempF - 300) / 25) * 25 + 300;
              // é‡æ–°è®¡ç®—å¯¹åº”çš„æ‘„æ°åº¦
              const adjustedTempC = fahrenheitToCelsius(tempF);
              const voltage = Math.round(20 + (tempF - 300) / 25);
              
              updateAllDisplays(tempF, adjustedTempC, voltage);
          });
        
        // å‘é€æ¸©åº¦è®¾ç½®å‘½ä»¤
        async function sendTemperatureSetting(tempF, tempC) {
            if (!txCharacteristic) {
                return;
            }
            
            try {
                const settingData = new Uint8Array([
                    0xcc, // å‘½ä»¤ç±»å‹ï¼šè®¾ç½®
                    0x10, // å­å‘½ä»¤ï¼šæ¸©åº¦è®¾ç½®
                    (tempF >> 8), (tempF & 0xff), 
                    (tempC >> 8), (tempC & 0xff), 
                    currentTempUnit,
                    currentVoltage,
                    currentAtomizerMode,
                    0x00,0x00,0x00,0x00,0x00,0x00,
                    0xcc,
                ]);
                
                await txCharacteristic.writeValue(settingData);
                const hexDisplay = uint8ArrayToHex(settingData);
                log(`ğŸ“¤ å‘é€æ¸©åº¦è®¾ç½®: <span class="hex-display">${hexDisplay}</span>`);
            } catch (error) {
                log(`âŒ å‘é€æ¸©åº¦è®¾ç½®å¤±è´¥: ${error.message}`);
            }
        }
        
        // OTA å·¥å…·å‡½æ•°
        function decimalToHex(d) {
            var hex = Number(d).toString(16);
            while (hex.length < 4) {
                hex = "0" + hex;
            }
            return hex;
        }
        
        function hexToBytes(hex) {
            var bytes = [];
            for (var c = 0; c < hex.length; c += 2)
                bytes.push(parseInt(hex.substr(c, 2), 16));
            return new Uint8Array(bytes);
        }
        
        function bytesToHex(data) {
            return new Uint8Array(data).reduce(function(memo, i) {
                return memo + ("0" + i.toString(16)).slice(-2);
            }, "");
        }
        
        function crc16_modbus(buffer) {
            var crc = 0xFFFF;
            var odd;
            for (var i = 0; i < buffer.length; i++) {
                crc = crc ^ buffer[i];
                for (var j = 0; j < 8; j++) {
                    odd = crc & 0x0001;
                    crc = crc >> 1;
                    if (odd) {
                        crc = crc ^ 0xA001;
                    }
                }
            }
            return crc;
        }
        
        function getHexCRC(data) {
            var tempCRC = decimalToHex(crc16_modbus(hexToBytes(data)));
            return tempCRC.substring(2, 4) + tempCRC.substring(0, 2);
        }
        
        function getHexBlockCount(count) {
            var tempHEX = decimalToHex(count);
            return tempHEX.substring(2, 4) + tempHEX.substring(0, 2);
        }
        
        // OTA çŠ¶æ€æ›´æ–°å‡½æ•°
        function updateOTAStatus(message, className) {
            const otaStatus = document.getElementById('otaStatus');
            otaStatus.textContent = `OTAçŠ¶æ€: ${message}`;
            otaStatus.className = `status ${className}`;
        }
        
        function updateOTAProgress(percentage, message) {
            const progressBar = document.getElementById('otaProgressBar');
            const progressText = document.getElementById('otaProgressText');
            const progressContainer = document.getElementById('otaProgress');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = message || `${percentage}%`;
        }
        
        // åŠ è½½å›ºä»¶æ–‡ä»¶
        async function loadFirmware() {
            try {
                const response = await fetch('./ota.bin');
                if (!response.ok) {
                    throw new Error(`æ— æ³•åŠ è½½å›ºä»¶æ–‡ä»¶: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                firmwareArray = bytesToHex(new Uint8Array(arrayBuffer));
                
                // éªŒè¯æ˜¯å¦ä¸º Telink å›ºä»¶
                if (firmwareArray.substring(16, 24) !== "4b4e4c54") {
                    throw new Error("æ‰€é€‰æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆçš„ Telink å›ºä»¶æ–‡ä»¶");
                }
                
                log(`ğŸ“ å›ºä»¶æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œå¤§å°: ${firmwareArray.length / 2} å­—èŠ‚`);
                
                // å¡«å……åˆ°16å­—èŠ‚è¾¹ç•Œ
                if (firmwareArray.length % 32 !== 0) {
                    var padHex = "ffffffffffffffffffffffffffffffff";
                    firmwareArray += padHex.substr(0, 32 - firmwareArray.length % 32);
                }
                otaBlockCount = firmwareArray.length / 32;
                log(`ğŸ“Š æ•°æ®å—æ•°é‡: ${otaBlockCount}`);
                
                return true;
            } catch (error) {
                log(`âŒ å›ºä»¶åŠ è½½å¤±è´¥: ${error.message}`);
                updateOTAStatus(`å›ºä»¶åŠ è½½å¤±è´¥: ${error.message}`, 'disconnected');
                return false;
            }
        }
        
        // è¿æ¥åˆ°OTAæœåŠ¡
        async function connectOTAService() {
            try {
                if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
                    throw new Error('è®¾å¤‡æœªè¿æ¥');
                }
                
                log('ğŸ”— è¿æ¥åˆ° OTA æœåŠ¡...');
                otaService = await bluetoothServer.getPrimaryService(OTA_SERVICE_UUID);
                otaCharacteristic = await otaService.getCharacteristic(OTA_CHARACTERISTIC_UUID);
                log('âœ… OTA æœåŠ¡è¿æ¥æˆåŠŸ');
                return true;
            } catch (error) {
                log(`âŒ OTA æœåŠ¡è¿æ¥å¤±è´¥: ${error.message}`);
                updateOTAStatus(`OTA æœåŠ¡è¿æ¥å¤±è´¥: ${error.message}`, 'disconnected');
                return false;
            }
        }
        
        // å‘é€OTAæ•°æ®
        async function otaCharSend(data) {
            return new Promise((resolve, reject) => {
                otaCharacteristic.writeValue(hexToBytes(data)).then(() => {
                    resolve("ok");
                }).catch((err) => {
                    reject("å‘é€OTAæ•°æ®æ—¶å‡ºé”™");
                });
            });
        }
        
        // å¼€å§‹OTAæ›´æ–°
        async function startOTA() {
            try {
                updateOTAStatus('å‡†å¤‡ä¸­...', 'connecting');
                
                // åŠ è½½å›ºä»¶
                if (!(await loadFirmware())) {
                    return;
                }
                
                // è¿æ¥OTAæœåŠ¡
                if (!(await connectOTAService())) {
                    return;
                }
                
                updateOTAStatus('å¼€å§‹OTAæ›´æ–°...', 'connecting');
                log('ğŸš€ å¼€å§‹ OTA æ›´æ–°æµç¨‹');
                
                // å¼€å§‹OTAåºåˆ—
                await otaCharSend("00ff");
                await new Promise(resolve => setTimeout(resolve, 100));
                await otaCharSend("01ff");
                await new Promise(resolve => setTimeout(resolve, 300));
                
                otaStartTime = new Date().getTime();
                await sendOTABlock(0);
                
            } catch (error) {
                log(`âŒ OTA æ›´æ–°å¤±è´¥: ${error.message}`);
                updateOTAStatus(`OTA æ›´æ–°å¤±è´¥: ${error.message}`, 'disconnected');
            }
        }
        
        // å‘é€OTAæ•°æ®å—
        async function sendOTABlock(blockNr) {
            try {
                if (blockNr >= otaBlockCount) {
                    await sendLastOTA();
                    return;
                }
                
                const percentage = Math.floor(blockNr / (otaBlockCount * 1.0) * 100);
                const elapsed = ((new Date().getTime() - otaStartTime) / 1000.0).toFixed(2);
                const statusMessage = `å‘é€æ•°æ®å— ${blockNr}/${otaBlockCount} (${percentage}%) - ${elapsed}s`;
                
                updateOTAStatus(statusMessage, 'connecting');
                updateOTAProgress(percentage, `${percentage}% - ${elapsed}s`);
                
                const blockNrString = getHexBlockCount(blockNr);
                const blockString = blockNrString + firmwareArray.substring(blockNr * 32, blockNr * 32 + 32);
                const blockCRC = getHexCRC(blockString);
                
                await otaCharSend(blockString + blockCRC);
                
                // æ¯8ä¸ªå—è¯»å–ä¸€æ¬¡çŠ¶æ€
                if ((blockNr + 1) % 8 === 0) {
                    await otaCharacteristic.readValue();
                    log('ğŸ“– è¯»å– OTA çŠ¶æ€');
                }
                
                // ç»§ç»­ä¸‹ä¸€ä¸ªå—
                setTimeout(() => sendOTABlock(blockNr + 1), 10);
                
            } catch (error) {
                log(`âŒ å‘é€æ•°æ®å— ${blockNr} å¤±è´¥: ${error.message}`);
                updateOTAStatus(`å‘é€æ•°æ®å—å¤±è´¥: ${error.message}`, 'disconnected');
            }
        }
        
        // å‘é€æœ€åçš„OTAå‘½ä»¤
        async function sendLastOTA() {
            try {
                const data = "02ff" + getHexBlockCount(otaBlockCount - 1) + getHexBlockCount(~(otaBlockCount - 1) & 0xffff);
                await otaCharSend(data);
                
                const totalTime = (new Date().getTime() - otaStartTime) / 1000;
                const successMessage = `OTA æ›´æ–°å®Œæˆ! è€—æ—¶ ${totalTime.toFixed(2)} ç§’`;
                
                log(`âœ… ${successMessage}`);
                updateOTAStatus(successMessage, 'connected');
                updateOTAProgress(100, 'æ›´æ–°å®Œæˆ!');
                
            } catch (error) {
                log(`âŒ å®Œæˆ OTA æ›´æ–°å¤±è´¥: ${error.message}`);
                updateOTAStatus(`å®Œæˆ OTA æ›´æ–°å¤±è´¥: ${error.message}`, 'disconnected');
            }
        }
        // DOMå…ƒç´ 
        const scanBtn = document.getElementById('scanBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const status = document.getElementById('status');
        const deviceInfo = document.getElementById('deviceInfo');
        const deviceName = document.getElementById('deviceName');
        const deviceId = document.getElementById('deviceId');
        const connectionState = document.getElementById('connectionState');
        const logArea = document.getElementById('logArea');
        const clearLogBtn = document.getElementById('clearLogBtn');
        const startOTABtn = document.getElementById('startOTABtn');

        // æ—¥å¿—åŠŸèƒ½
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message, className) {
            status.textContent = message;
            status.className = `status ${className}`;
        }

        // æ›´æ–°UIçŠ¶æ€
        function updateUI(connected) {
            scanBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            startOTABtn.disabled = !connected;
            
            if (connected) {
                deviceInfo.style.display = 'block';
                deviceName.textContent = bluetoothDevice.name || 'æœªçŸ¥è®¾å¤‡';
                deviceId.textContent = bluetoothDevice.id;
                connectionState.textContent = 'å·²è¿æ¥';
                updateOTAStatus('è®¾å¤‡å·²è¿æ¥ï¼Œå¯ä»¥å¼€å§‹OTAæ›´æ–°', 'connected');
            } else {
                deviceInfo.style.display = 'none';
                // éšè—è®¾å¤‡æ•°æ®å¡ç‰‡
                document.getElementById('deviceDataCard').style.display = 'none';
                updateOTAStatus('ç­‰å¾…è¿æ¥è®¾å¤‡', 'disconnected');
                // éšè—è¿›åº¦æ¡
                document.getElementById('otaProgress').style.display = 'none';
            }
        }

        // 16è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºUint8Array
        function hexStringToUint8Array(hexString) {
            // ç§»é™¤ç©ºæ ¼å’Œé16è¿›åˆ¶å­—ç¬¦
            const cleanHex = hexString.replace(/[^0-9A-Fa-f]/g, '');
            
            // ç¡®ä¿æ˜¯å¶æ•°é•¿åº¦
            const paddedHex = cleanHex.length % 2 ? '0' + cleanHex : cleanHex;
            
            const bytes = new Uint8Array(paddedHex.length / 2);
            for (let i = 0; i < paddedHex.length; i += 2) {
                bytes[i / 2] = parseInt(paddedHex.substr(i, 2), 16);
            }
            return bytes;
        }

        // Uint8Arrayè½¬æ¢ä¸º16è¿›åˆ¶å­—ç¬¦ä¸²
        function uint8ArrayToHex(bytes) {
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join(' ').toUpperCase();
        }

        // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
        function handleNotification(event) {
            const value = event.target.value;
            const bytes = new Uint8Array(value.buffer);
            const hexString = uint8ArrayToHex(bytes);
            
            log(`ğŸ“¥ æ¥æ”¶æ•°æ®: <span class="hex-display">${hexString}</span>`);
            log(`ğŸ“¥ åŸå§‹æ•°æ®: [${Array.from(bytes).join(', ')}]`);
            
            // è§£æè®¾å¤‡æ•°æ®
            parseDeviceData(bytes);
        }
        
        // è§£æè®¾å¤‡æ•°æ®
        function parseDeviceData(bytes) {
            if (bytes.length < 20) {
                log('âš ï¸ æ•°æ®åŒ…é•¿åº¦ä¸è¶³ï¼Œæ— æ³•è§£æè®¾å¤‡ä¿¡æ¯');
                return;
            }
            
            try {

                const atomizerType = getAtomizerType(bytes[2]); // Byte3: é›¾åŒ–å™¨ç±»å‹
                const tempUnit = getTempUnit(bytes[3]); // Byte4: æ¸©åº¦å•ä½


        //                 let currentAtomizerMode = 0xa0; // é»˜è®¤æ¸©åº¦æ¨¡å¼
        // let currentTempUnit = 0x11; // é»˜è®¤åæ°åº¦
        // let currentVoltage = 40;
        // let currentTempF = 800;
        // let currentTempC = 426;


                currentAtomizerMode = bytes[2];
                currentTempUnit = bytes[3];
                const batteryLevel = bytes[4]; // Byte5: ç”µæ± ç”µé‡ç™¾åˆ†æ¯”
                
                // ç”µå‹è®¾ç½® (Byte6): 30~3.0V
                const voltageValue = (bytes[5] / 10).toFixed(1);
                
                // å½“å‰æ¸©åº¦è®¾ç½®(åæ°åº¦) Byte7æ˜¯ä½ä½ï¼ŒByte8æ˜¯é«˜ä½
                const currentTempF = (bytes[6] << 8) + bytes[7];
                
                // å½“å‰æ¸©åº¦è®¾ç½®(æ‘„æ°åº¦) Byte9æ˜¯ä½ä½ï¼ŒByte10æ˜¯é«˜ä½  
                const currentTempC = (bytes[8] << 8) + bytes[9];
                
                // å½“å‰é˜»å€¼ Byte11æ˜¯ä½ä½ï¼ŒByte12æ˜¯é«˜ä½ (å•ä½: mÎ©)
                const currentResistance = (((bytes[10] << 8) + bytes[11]) / 100).toFixed(2);
                
                // å½“å‰åŠŸç‡ Byte13æ˜¯ä½ä½ï¼ŒByte14æ˜¯é«˜ä½ (å•ä½: mW)
                const currentPower = (((bytes[12] << 8) + bytes[13]) / 10).toFixed(1);
                
                // Puffè®¡æ•°1 Byte15æ˜¯ä½ä½ï¼ŒByte16æ˜¯é«˜ä½
                const puffCount1 = (bytes[14] << 8) + bytes[15];
                
                // Puffè®¡æ•°2 Byte17æ˜¯ä½ä½ï¼ŒByte18æ˜¯é«˜ä½
                const puffCount2 = (bytes[16] << 8) + bytes[17];
                

                currentVoltage = bytes[5];
                current_TempF = currentTempF;
                current_TempC = currentTempC;

                // æ›´æ–°UIæ˜¾ç¤º
                updateDeviceDataDisplay({
                    atomizerType,
                    tempUnit,
                    batteryLevel: `${batteryLevel}%`,
                    currentVoltage: `${voltageValue}V`,
                    currentTempF: `${currentTempF}Â°F`,
                    currentTempC: `${currentTempC}Â°C`,
                    currentResistance: `${currentResistance}Î©`,
                    currentPower: `${currentPower}W`,
                    puffCount1,
                    puffCount2
                });
                
                // æ˜¾ç¤ºè®¾å¤‡æ•°æ®å¡ç‰‡
                document.getElementById('deviceDataCard').style.display = 'block';
                
            } catch (error) {
                log(`âŒ è§£æè®¾å¤‡æ•°æ®å¤±è´¥: ${error.message}`);
            }
        }
        
        // è·å–é›¾åŒ–å™¨ç±»å‹
        function getAtomizerType(byte) {
            switch(byte) {
                case 0xa0: return 'Temp mode';
                case 0x60: return 'Voltage mode';
                case 0x00: return 'No Atomizer';
                default: return `Unknown (0x${byte.toString(16).toUpperCase()})`;
            }
        }
        
        // è·å–æ¸©åº¦å•ä½
        function getTempUnit(byte) {
            switch(byte) {
                case 0x11: return 'Fahrenheit';
                case 0x22: return 'Celsius';
                default: return `Unknown (0x${byte.toString(16).toUpperCase()})`;
            }
        }
        
        // æ›´æ–°è®¾å¤‡æ•°æ®æ˜¾ç¤º
        function updateDeviceDataDisplay(data) {
            document.getElementById('atomizerType').textContent = data.atomizerType;
            document.getElementById('tempUnit').textContent = data.tempUnit;
            document.getElementById('batteryLevel').textContent = data.batteryLevel;
            document.getElementById('currentVoltage').textContent = data.currentVoltage;
            document.getElementById('currentTempF').textContent = data.currentTempF;
            document.getElementById('currentTempC').textContent = data.currentTempC;
            document.getElementById('currentResistance').textContent = data.currentResistance;
            document.getElementById('currentPower').textContent = data.currentPower;
            document.getElementById('puffCount1').textContent = data.puffCount1;
            document.getElementById('puffCount2').textContent = data.puffCount2;
            
            // æ›´æ–°å½“å‰çŠ¶æ€å˜é‡ï¼Œä¿æŒåŒæ­¥
            if (data.atomizerType === 'Temp mode') {
                currentAtomizerMode = 0xa0;
            } else if (data.atomizerType === 'Voltage mode') {
                currentAtomizerMode = 0x60;
            } else if (data.atomizerType === 'No Atomizer') {
                currentAtomizerMode = 0x00;
            }
            
            if (data.tempUnit === 'Fahrenheit') {
                currentTempUnit = 0x11;
            } else if (data.tempUnit === 'Celsius') {
                currentTempUnit = 0x22;
            }
        }

        // æ‰«æå¹¶è¿æ¥è®¾å¤‡
        async function scanAndConnect() {
            try {
                updateStatus('æ­£åœ¨æ‰«æè®¾å¤‡...', 'connecting');
                log('ğŸ” å¼€å§‹æ‰«æè“ç‰™è®¾å¤‡...');

                // è¯·æ±‚è“ç‰™è®¾å¤‡
                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true // æ¥å—æ‰€æœ‰è®¾å¤‡
                });

                log(`ğŸ“± æ‰¾åˆ°è®¾å¤‡: ${bluetoothDevice.name || 'æœªçŸ¥è®¾å¤‡'}`);
                log(`ğŸ“± è®¾å¤‡ID: ${bluetoothDevice.id}`);

                // ç›‘å¬æ–­å¼€è¿æ¥äº‹ä»¶
                bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);

                updateStatus('æ­£åœ¨è¿æ¥...', 'connecting');
                log('ğŸ”— æ­£åœ¨è¿æ¥åˆ°è®¾å¤‡...');

                // è¿æ¥åˆ°GATTæœåŠ¡å™¨
                bluetoothServer = await bluetoothDevice.gatt.connect();
                log('âœ… GATTæœåŠ¡å™¨è¿æ¥æˆåŠŸ');

                // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©è®¾å¤‡å‡†å¤‡å¥½
                await new Promise(resolve => setTimeout(resolve, 1000));
                log('â³ ç­‰å¾…è®¾å¤‡å‡†å¤‡å°±ç»ª...');

                // è·å–æ‰€æœ‰å¯ç”¨æœåŠ¡
                let services;
                try {
                    services = await bluetoothServer.getPrimaryServices();
                    log(`âœ… å‘ç° ${services.length} ä¸ªæœåŠ¡`);
                } catch (error) {
                    log(`âŒ è·å–æœåŠ¡å¤±è´¥: ${error.message}`);
                    // å°è¯•ä½¿ç”¨å·²çŸ¥çš„æœåŠ¡UUID
                    try {
                        const knownService = await bluetoothServer.getPrimaryService(SERVICE_UUID);
                        services = [knownService];
                        log('âœ… ä½¿ç”¨å·²çŸ¥æœåŠ¡UUIDæˆåŠŸ');
                    } catch (e) {
                        throw new Error('æ— æ³•è·å–ä»»ä½•æœåŠ¡ï¼Œè®¾å¤‡å¯èƒ½ä¸å…¼å®¹');
                    }
                }
                
                // å°è¯•æ‰¾åˆ°åŒ…å«é€šçŸ¥ç‰¹å¾çš„æœåŠ¡
                let foundService = null;
                let foundRxChar = null;
                let foundTxChar = null;
                
                for (const svc of services) {
                    try {
                        const characteristics = await svc.getCharacteristics();
                        log(`æœåŠ¡ ${svc.uuid} æœ‰ ${characteristics.length} ä¸ªç‰¹å¾`);
                        
                        for (const char of characteristics) {
                            if (char.properties.notify || char.properties.indicate) {
                                foundRxChar = char;
                                foundService = svc;
                                log(`âœ… æ‰¾åˆ°é€šçŸ¥ç‰¹å¾: ${char.uuid}`);
                            }
                            if (char.properties.write || char.properties.writeWithoutResponse) {
                                foundTxChar = char;
                                log(`âœ… æ‰¾åˆ°å†™å…¥ç‰¹å¾: ${char.uuid}`);
                            }
                        }
                        
                        if (foundRxChar && foundTxChar) {
                            break;
                        }
                    } catch (e) {
                        log(`è·³è¿‡æœåŠ¡ ${svc.uuid}: ${e.message}`);
                    }
                }
                
                if (!foundService || !foundRxChar) {
                    throw new Error('æœªæ‰¾åˆ°åˆé€‚çš„æœåŠ¡å’Œç‰¹å¾');
                }
                
                service = foundService;
                rxCharacteristic = foundRxChar;
                txCharacteristic = foundTxChar;
                log('âœ… è·å–åˆ°æœåŠ¡å’Œç‰¹å¾');

                // å¯ç”¨é€šçŸ¥
                await rxCharacteristic.startNotifications();
                rxCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);
                log('âœ… é€šçŸ¥åŠŸèƒ½å·²å¯ç”¨');

                updateStatus('è¿æ¥æˆåŠŸ', 'connected');
                updateUI(true);
                log('ğŸ‰ è®¾å¤‡è¿æ¥æˆåŠŸï¼Œå¯ä»¥å¼€å§‹é€šä¿¡äº†ï¼');

            } catch (error) {
                log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`);
                updateStatus('è¿æ¥å¤±è´¥', 'disconnected');
                updateUI(false);
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
                log('ğŸ”Œ æ‰‹åŠ¨æ–­å¼€è¿æ¥');
            }
        }

        // å¤„ç†æ–­å¼€è¿æ¥äº‹ä»¶
        function onDisconnected() {
            log('âŒ è®¾å¤‡å·²æ–­å¼€è¿æ¥');
            updateStatus('è¿æ¥å·²æ–­å¼€', 'disconnected');
            updateUI(false);
            
            // æ¸…ç†å˜é‡
            bluetoothDevice = null;
            bluetoothServer = null;
            service = null;
            rxCharacteristic = null;
            txCharacteristic = null;
        }


        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            logArea.innerHTML = 'æ—¥å¿—å·²æ¸…ç©º<br>';
        }
        
        // åˆ‡æ¢é›¾åŒ–å™¨ç±»å‹
        function toggleAtomizerType() {
            if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
                log('âŒ è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•åˆ‡æ¢é›¾åŒ–å™¨ç±»å‹');
                return;
            }
            
            // åˆ‡æ¢é›¾åŒ–å™¨æ¨¡å¼
            if (currentAtomizerMode === 0xa0) {
                currentAtomizerMode = 0x60; // åˆ‡æ¢åˆ°ç”µå‹æ¨¡å¼
            } else {
                currentAtomizerMode = 0xa0; // åˆ‡æ¢åˆ°æ¸©åº¦æ¨¡å¼
            }
            
            // æ›´æ–°æ˜¾ç¤º
            const atomizerTypeElement = document.getElementById('atomizerType');
            atomizerTypeElement.textContent = getAtomizerType(currentAtomizerMode);
            
            // å‘é€è®¾ç½®å‘½ä»¤
            sendAtomizerTypeSetting();
            
            log(`ğŸ”„ é›¾åŒ–å™¨ç±»å‹å·²åˆ‡æ¢ä¸º: ${getAtomizerType(currentAtomizerMode)}`);
        }
        
        // åˆ‡æ¢æ¸©åº¦å•ä½
        function toggleTempUnit() {
            if (!bluetoothDevice || !bluetoothDevice.gatt.connected) {
                log('âŒ è®¾å¤‡æœªè¿æ¥ï¼Œæ— æ³•åˆ‡æ¢æ¸©åº¦å•ä½');
                return;
            }
            
            // åˆ‡æ¢æ¸©åº¦å•ä½
            if (currentTempUnit === 0x11) {
                currentTempUnit = 0x22; // åˆ‡æ¢åˆ°æ‘„æ°åº¦
            } else {
                currentTempUnit = 0x11; // åˆ‡æ¢åˆ°åæ°åº¦
            }
            
            // æ›´æ–°æ˜¾ç¤º
            const tempUnitElement = document.getElementById('tempUnit');
            tempUnitElement.textContent = getTempUnit(currentTempUnit);
            
            // å‘é€è®¾ç½®å‘½ä»¤
            sendTempUnitSetting();
            
            log(`ğŸ”„ æ¸©åº¦å•ä½å·²åˆ‡æ¢ä¸º: ${getTempUnit(currentTempUnit)}`);
        }
        
        // å‘é€é›¾åŒ–å™¨ç±»å‹è®¾ç½®å‘½ä»¤
        async function sendAtomizerTypeSetting() {
            if (!txCharacteristic) {
                log('âŒ TXç‰¹å¾ä¸å¯ç”¨ï¼Œæ— æ³•å‘é€è®¾ç½®å‘½ä»¤');
                return;
            }
            
            try {
                // æ„é€ è®¾ç½®å‘½ä»¤æ•°æ®åŒ… (æ ¹æ®åè®®æ–‡æ¡£è°ƒæ•´)
                const settingData = new Uint8Array([
                    0xcc, // å‘½ä»¤ç±»å‹ï¼šè®¾ç½®
                    0x10, // å­å‘½ä»¤ï¼šé›¾åŒ–å™¨ç±»å‹
                    (current_TempF >> 8), (current_TempF & 0xff), 
                    (current_TempC >> 8), (current_TempC & 0xff), 
                    currentTempUnit,
                    currentVoltage,
                    currentAtomizerMode,
                    0x00,0x00,0x00,0x00,0x00,0x00,
                    0xcc,
                ]);
                
                await txCharacteristic.writeValue(settingData);
                const hexDisplay = uint8ArrayToHex(settingData);
                log(`ğŸ“¤ å‘é€é›¾åŒ–å™¨è®¾ç½®: <span class="hex-display">${hexDisplay}</span>`);
            } catch (error) {
                log(`âŒ å‘é€é›¾åŒ–å™¨è®¾ç½®å¤±è´¥: ${error.message}`);
            }
        }
        
        // å‘é€æ¸©åº¦å•ä½è®¾ç½®å‘½ä»¤
        async function sendTempUnitSetting() {
            if (!txCharacteristic) {
                log('âŒ TXç‰¹å¾ä¸å¯ç”¨ï¼Œæ— æ³•å‘é€è®¾ç½®å‘½ä»¤');
                return;
            }
            
            try {
                // æ„é€ è®¾ç½®å‘½ä»¤æ•°æ®åŒ… (æ ¹æ®åè®®æ–‡æ¡£è°ƒæ•´)
                const settingData = new Uint8Array([
                    0xcc, // å‘½ä»¤ç±»å‹ï¼šè®¾ç½®
                    0x10, // å­å‘½ä»¤ï¼šé›¾åŒ–å™¨ç±»å‹
                    (current_TempF >> 8), (current_TempF & 0xff), 
                    (current_TempC >> 8), (current_TempC & 0xff), 
                    currentTempUnit,
                    currentVoltage,
                    currentAtomizerMode,
                    0x00,0x00,0x00,0x00,0x00,0x00,
                    0xcc,
                ]);
                
                await txCharacteristic.writeValue(settingData);
                const hexDisplay = uint8ArrayToHex(settingData);
                log(`ğŸ“¤ å‘é€æ¸©åº¦å•ä½è®¾ç½®: <span class="hex-display">${hexDisplay}</span>`);
            } catch (error) {
                log(`âŒ å‘é€æ¸©åº¦å•ä½è®¾ç½®å¤±è´¥: ${error.message}`);
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        scanBtn.addEventListener('click', scanAndConnect);
        disconnectBtn.addEventListener('click', disconnect);
        startOTABtn.addEventListener('click', startOTA);
        clearLogBtn.addEventListener('click', clearLog);
        
        // é¡µé¢åŠ è½½å®Œæˆåæ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            // ä¸ºé›¾åŒ–å™¨ç±»å‹æ·»åŠ ç‚¹å‡»äº‹ä»¶
            const atomizerTypeElement = document.getElementById('atomizerType');
            if (atomizerTypeElement) {
                atomizerTypeElement.addEventListener('click', toggleAtomizerType);
            }
            
            // ä¸ºæ¸©åº¦å•ä½æ·»åŠ ç‚¹å‡»äº‹ä»¶
            const tempUnitElement = document.getElementById('tempUnit');
            if (tempUnitElement) {
                tempUnitElement.addEventListener('click', toggleTempUnit);
            }
            
            // åˆå§‹åŒ–æ¸©åº¦æ˜¾ç¤º
             const initialTempF = 500;
             const initialTempC = fahrenheitToCelsius(initialTempF);
             const initialVoltage = Math.round(20 + (initialTempF - 300) / 25);
             
             // ä½¿ç”¨ç»Ÿä¸€çš„æ›´æ–°å‡½æ•°åˆå§‹åŒ–æ‰€æœ‰æ˜¾ç¤º
              updateAllDisplays(initialTempF, initialTempC, initialVoltage);
              
              // ç¡®ä¿æ»‘å—èŒƒå›´æ­£ç¡®
              tempCSlider.min = fahrenheitToCelsius(300);
              tempCSlider.max = fahrenheitToCelsius(800);
              
              // åˆå§‹åŒ–OTAçŠ¶æ€
              updateOTAStatus('ç­‰å¾…è¿æ¥è®¾å¤‡', 'disconnected');
        });
        
        


        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
        if (!navigator.bluetooth) {
            log('âŒ æ­¤æµè§ˆå™¨ä¸æ”¯æŒWeb Bluetooth API');
            scanBtn.disabled = true;
        } else {
            log('âœ… æµè§ˆå™¨æ”¯æŒWeb Bluetooth APIï¼Œå¯ä»¥å¼€å§‹ä½¿ç”¨');
        }
    </script>
</body>
</html>




