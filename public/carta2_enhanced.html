<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluetooth Device Status Panel</title>
  <!-- Include SheetJS library for Excel file generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: sans-serif; background: #f8fbff; padding: 2em; }
    h2 { margin-bottom: 1em; }
    .panel { background: #fff; padding: 1em; border-radius: 10px; box-shadow: 0 0 6px #ccc; max-width: 500px; margin-bottom: 1em; }
    .row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #ddd; }
    .row:last-child { border: none; }
    label { font-weight: bold; }
    .val { font-family: monospace; }
    button, input { margin: 0.5em 0; padding: 0.6em; font-size: 1em; }
    .form { margin-top: 1em; }
    
    /* Data Recording Status Styles */
    .recording-panel {
      background: #fff3cd;
      border: 2px solid #ffc107;
    }
    .recording-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #dc3545;
      margin-right: 8px;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    .status-recording { color: #dc3545; font-weight: bold; }
    .status-idle { color: #6c757d; }
    .status-stopped { color: #28a745; font-weight: bold; }
  </style>
</head>
<body>

<h2>ğŸ“¡ Bluetooth Status Panel</h2>
<button id="connectBtn">ğŸ”— Connect Bluetooth Device</button>

<!-- Data Recording Control Panel -->
<div class="panel" id="recordingPanel">
  <div class="row">
    <label>ğŸ“Š Recording Status:</label>
    <span class="val status-idle" id="recordingStatus">Idle</span>
  </div>
  <div class="row">
    <label>Data Points Recorded:</label>
    <span class="val" id="recordedCount">0</span>
  </div>
  <div class="row">
    <label>Stop Detection Time:</label>
    <span class="val">
      <input type="number" id="stopThreshold" value="5" min="1" max="60" style="width: 60px;"> seconds
    </span>
  </div>
  <div class="row">
    <button id="manualExportBtn" style="background: #28a745; color: white;">ğŸ’¾ Export to Excel</button>
    <button id="clearDataBtn" style="background: #dc3545; color: white;">ğŸ—‘ï¸ Clear Data</button>
  </div>
</div>

<div class="form">
  <label for="ssid">SSID:</label>
  <input type="text" id="ssid" placeholder="Enter WiFi SSID">
  <label for="password">Password:</label>
  <input type="text" id="password" placeholder="Enter WiFi password">
  <button id="startWifiBtn">ğŸš€ Start WiFi</button>

  <!-- OTA BIN Upload -->
  <div style="margin-top:1em;">
    <label for="binFile">Select OTA Firmware (.bin):</label>
    <input type="file" id="binFile" accept=".bin">
    <button id="sendBinBtn">ğŸ“¦ Send OTA BIN</button>
  </div>

  <!-- OTA URL Input -->
  <div style="margin-top: 1em;">
  <label for="otaUrl">OTA URL:</label>
  <input type="text" id="otaUrl" placeholder="Enter OTA download URL" style="width: 50%;">
  <button id="startOtaBtn">â¬‡ï¸ Start WiFi OTA</button>
  </div>

  <div class="form">
  <label for="hexInput">Send Hex Data Manually:</label>
  <input type="text" id="hexInput" placeholder="e.g. AA 01 FF 00" style="width: 60%;">
  <button id="sendHexBtn">ğŸ“¤ Send Hex</button>
  <button id="sendAsciiBtn">ğŸ“ Send ASCII</button>
  </div>

  <!-- Wattage Control -->
  <div class="form">
    <label for="wattageSideSlider">Wattage Side (0-60W):</label>
    <button id="sideMinusBtn" title="Decrease">-</button>
    <input type="range" id="wattageSideSlider" min="0" max="60" value="30" style="width: 50%;">
    <button id="sidePlusBtn" title="Increase">+</button>
    <span id="wattageSideValue">30</span>W
  </div>
  
  <div class="form">
    <label for="wattageBottomSlider">Wattage Bottom (0-60W):</label>
    <button id="bottomMinusBtn" title="Decrease">-</button>
    <input type="range" id="wattageBottomSlider" min="0" max="60" value="30" style="width: 50%;">
    <button id="bottomPlusBtn" title="Increase">+</button>
    <span id="wattageBottomValue">30</span>W
  </div>
  
  <div class="form">
    <label>Total Power:</label>
    <span id="totalWattage" style="font-weight: bold; color: #dc3545;">60</span>W / 60W (Max)
  </div>
  
  <div class="form">
    <label>Calculated Percentage:</label>
    <span id="calculatedPercent" style="font-weight: bold; color: #07c160;">50</span>%
  </div>
  
  <div class="form">
    <label for="bottomWattagePercentSlider">Bottom Wattage Percent (0-100%):</label>
    <button id="bottomPercentMinusBtn" title="Decrease">-</button>
    <input type="range" id="bottomWattagePercentSlider" min="0" max="100" value="50" style="width: 50%;">
    <button id="bottomPercentPlusBtn" title="Increase">+</button>
    <span id="bottomWattagePercentValue">50</span>%
  </div>
  
  <div class="form">
    <label for="switchTimeSlider">Switch Time Point (0-60s):</label>
    <button id="switchTimeMinusBtn" title="Decrease">-</button>
    <input type="range" id="switchTimeSlider" min="0" max="60" value="30" style="width: 50%;">
    <button id="switchTimePlusBtn" title="Increase">+</button>
    <span id="switchTimeValue">30</span>s
  </div>
  
  <div class="form">
    <button id="sendWattageBtn" style="background: #07c160; color: white; margin-left: 10px;">ğŸ“¤ Send Data</button>
  </div>

</div>

<div class="panel" id="statusPanel">
  <div class="row"><label>Atomizer Type:</label><span class="val" id="atomizer">--</span></div>
  <div class="row"><label>Dry Herb Preset:</label><span class="val" id="dryPreset">--</span></div>
  <div class="row"><label>Gesso Preset:</label><span class="val" id="gessoPreset">--</span></div>
  <div class="row"><label>Countdown:</label><span class="val" id="countdown">--</span></div>
  <div class="row"><label>Current Temp:</label><span class="val" id="curTemp">--</span></div>
  <div class="row"><label>Preset Temp:</label><span class="val" id="presetTemp">--</span></div>
  <div class="row"><label>Battery Level:</label><span class="val" id="battery">--</span></div>
  <div class="row"><label>LED Preset:</label><span class="val" id="ledPreset">--</span></div>
  <div class="row"><label>Dry Herb Time:</label><span class="val" id="dryTime">--</span></div>
  <div class="row"><label>Gesso Time:</label><span class="val" id="gessoTime">--</span></div>
</div>
<div class="panel" id="chartPanel">
  <div class="row"><label>ğŸ“ˆ Real-time Temperature Chart</label><span class="val">Side â€¢ Bottom â€¢ Side Power â€¢ Bottom Power</span></div>
  <div class="row">
    <span class="val" style="color:#e74c3c">Side: <span id="curSide">--</span></span>
    <span class="val" style="color:#3498db">Bottom: <span id="curBottom">--</span></span>
  </div>
  <div class="row">
    <span class="val" style="color:#2ecc71">Side Power: <span id="curSidePower">--</span>W</span>
    <span class="val" style="color:#f39c12">Bottom Power: <span id="curBottomPower">--</span>W</span>
  </div>
  <canvas id="chartCanvas" width="500" height="240"></canvas>
  <div class="row">
    <span style="color:#e74c3c">â— Side Temp</span>
    <span style="color:#3498db">â— Bottom Temp</span>
    <span style="color:#2ecc71">â— Side Power</span>
    <span style="color:#f39c12">â— Bottom Power</span>
  </div>
</div>

<script>
let characteristicToWrite = null; // Save writable characteristic

// ==================== Data Recording Related Variables ====================
let recordedData = []; // Store all collected data
let isRecording = false; // Whether recording is in progress
let lastDataTime = null; // Last time data was received
let stopCheckInterval = null; // Stop detection timer
let recordingStartTime = null; // Recording start time

// Update recording status display
function updateRecordingStatus(status) {
  const statusEl = document.getElementById('recordingStatus');
  const panelEl = document.getElementById('recordingPanel');
  
  if (status === 'recording') {
    statusEl.innerHTML = '<span class="recording-indicator"></span>Recording...';
    statusEl.className = 'val status-recording';
    panelEl.classList.add('recording-panel');
    isRecording = true;
  } else if (status === 'stopped') {
    statusEl.textContent = 'Completed';
    statusEl.className = 'val status-stopped';
    panelEl.classList.remove('recording-panel');
    isRecording = false;
  } else {
    statusEl.textContent = 'Idle';
    statusEl.className = 'val status-idle';
    panelEl.classList.remove('recording-panel');
    isRecording = false;
  }
}

// Start data recording
function startRecording() {
  if (isRecording) return;
  
  recordedData = [];
  recordingStartTime = new Date();
  updateRecordingStatus('recording');
  
  console.log('âœ… Start data recording');
  
  // Start stop detection timer
  startStopDetection();
}

// Stop data recording and export
function stopRecording() {
  if (!isRecording) return;
  
  updateRecordingStatus('stopped');
  console.log(`âœ… Recording completed, ${recordedData.length} data points collected`);
  
  // Stop detection timer
  if (stopCheckInterval) {
    clearInterval(stopCheckInterval);
    stopCheckInterval = null;
  }
  
  // Auto export to Excel
  if (recordedData.length > 0) {
    exportToExcel();
  } else {
    alert('No data collected');
  }
}

// Start stop detection
function startStopDetection() {
  if (stopCheckInterval) {
    clearInterval(stopCheckInterval);
  }
  
  stopCheckInterval = setInterval(() => {
    if (!isRecording) return;
    
    const threshold = parseInt(document.getElementById('stopThreshold').value) * 1000;
    const now = Date.now();
    
    if (lastDataTime && (now - lastDataTime) > threshold) {
      console.log(`â¹ï¸ Data stopped for more than ${threshold/1000} seconds, auto-stop recording`);
      stopRecording();
    }
  }, 1000);
}

// Record data point
function recordDataPoint(side, bottom, totalPower, sidePower, bottomPower) {
  const timestamp = new Date();
  const dataPoint = {
    timestamp: timestamp.toISOString(),
    time: timestamp.toLocaleString('en-US'),
    side: side,
    bottom: bottom,
    totalPower: totalPower,
    sidePower: sidePower,
    bottomPower: bottomPower
  };
  
  recordedData.push(dataPoint);
  lastDataTime = Date.now();
  
  // Update display
  document.getElementById('recordedCount').textContent = recordedData.length;
  
  // Auto start recording if not started
  if (!isRecording) {
    startRecording();
  }
}

// Export to Excel file
function exportToExcel() {
  if (recordedData.length === 0) {
    alert('No data to export');
    return;
  }
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Prepare data
  const wsData = [
    ['Timestamp', 'Time', 'Side Temperature', 'Bottom Temperature', 'Total Power', 'Side Power', 'Bottom Power'],
    ...recordedData.map(d => [d.timestamp, d.time, d.side, d.bottom, d.totalPower, d.sidePower, d.bottomPower])
  ];
  
  // Add statistics
  wsData.push([]);
  wsData.push(['Statistics']);
  wsData.push(['Total Data Points', recordedData.length]);
  wsData.push(['Recording Start Time', recordingStartTime ? recordingStartTime.toLocaleString('en-US') : '']);
  wsData.push(['Recording End Time', new Date().toLocaleString('en-US')]);
  
  if (recordedData.length > 0) {
    const sides = recordedData.map(d => d.side);
    const bottoms = recordedData.map(d => d.bottom);
    const totalPowers = recordedData.map(d => d.totalPower);
    const sidePowers = recordedData.map(d => d.sidePower);
    const bottomPowers = recordedData.map(d => d.bottomPower);
    
    wsData.push([]);
    wsData.push(['Side Temperature - Min', Math.min(...sides).toFixed(2)]);
    wsData.push(['Side Temperature - Max', Math.max(...sides).toFixed(2)]);
    wsData.push(['Side Temperature - Average', (sides.reduce((a,b) => a+b, 0) / sides.length).toFixed(2)]);
    wsData.push([]);
    wsData.push(['Bottom Temperature - Min', Math.min(...bottoms).toFixed(2)]);
    wsData.push(['Bottom Temperature - Max', Math.max(...bottoms).toFixed(2)]);
    wsData.push(['Bottom Temperature - Average', (bottoms.reduce((a,b) => a+b, 0) / bottoms.length).toFixed(2)]);
    wsData.push([]);
    wsData.push(['Total Power - Min', Math.min(...totalPowers).toFixed(2)]);
    wsData.push(['Total Power - Max', Math.max(...totalPowers).toFixed(2)]);
    wsData.push(['Total Power - Average', (totalPowers.reduce((a,b) => a+b, 0) / totalPowers.length).toFixed(2)]);
    wsData.push([]);
    wsData.push(['Side Power - Min', Math.min(...sidePowers).toFixed(2)]);
    wsData.push(['Side Power - Max', Math.max(...sidePowers).toFixed(2)]);
    wsData.push(['Side Power - Average', (sidePowers.reduce((a,b) => a+b, 0) / sidePowers.length).toFixed(2)]);
    wsData.push([]);
    wsData.push(['Bottom Power - Min', Math.min(...bottomPowers).toFixed(2)]);
    wsData.push(['Bottom Power - Max', Math.max(...bottomPowers).toFixed(2)]);
    wsData.push(['Bottom Power - Average', (bottomPowers.reduce((a,b) => a+b, 0) / bottomPowers.length).toFixed(2)]);
  }
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths
  ws['!cols'] = [
    { wch: 25 },
    { wch: 20 },
    { wch: 18 },
    { wch: 20 },
    { wch: 12 },
    { wch: 12 },
    { wch: 14 }
  ];
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Temperature Data');
  
  // Generate filename
  const filename = `Temperature_Data_${new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)}.xlsx`;
  
  // Download file
  XLSX.writeFile(wb, filename);
  
  console.log(`âœ… Excel file exported: ${filename}`);
  alert(`Data exported to file: ${filename}\nTotal ${recordedData.length} data points`);
}

// Clear recorded data
function clearRecordedData() {
  if (isRecording) {
    const confirm = window.confirm('Recording in progress. Are you sure you want to clear the data?');
    if (!confirm) return;
    
    // Stop recording
    if (stopCheckInterval) {
      clearInterval(stopCheckInterval);
      stopCheckInterval = null;
    }
  }
  
  recordedData = [];
  document.getElementById('recordedCount').textContent = '0';
  updateRecordingStatus('idle');
  console.log('ğŸ—‘ï¸ Data cleared');
}

// Button event bindings
document.getElementById('manualExportBtn').addEventListener('click', () => {
  if (recordedData.length === 0) {
    alert('No data to export');
    return;
  }
  exportToExcel();
});

document.getElementById('clearDataBtn').addEventListener('click', () => {
  const confirm = window.confirm('Are you sure you want to clear all recorded data?');
  if (confirm) {
    clearRecordedData();
  }
});

// ==================== Original Code ====================

/* Wait for device to return AWK (41 57 4B) with timeout */
function waitForAck(timeout = 6000) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      console.warn("âš ï¸ ACK timeout, no device response received");
      reject(new Error("AWK timeout"));
    }, timeout);

    // Save a trigger globally, will be called when AWK is received
    ackResolver = () => {
      clearTimeout(timer);
      resolve();
    };
  });
}


function set(id, value) {
  document.getElementById(id).textContent = value;
}

// Chart data arrays
const chartDataSide = [];
const chartDataBottom = [];
const chartDataSidePower = [];
const chartDataBottomPower = [];
const chartMaxPoints = 200;

// Global variables to store current settings
let currentCountdown = 0;
let currentSwitchTimePoint = 30;
let currentCalculatedPercent = 50;
let currentBottomWattagePercent = 50;

function drawChart() {
  const c = document.getElementById('chartCanvas');
  if (!c) return;
  
  const ctx = c.getContext('2d');
  const w = c.width;
  const h = c.height;
  const margin = 30;
  const plotWidth = w - margin * 2;
  const plotHeight = h - margin * 2;
  
  // Clear canvas
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, w, h);
  
  // Draw grid lines
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = margin + (i / 4) * plotHeight;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(margin + plotWidth, y);
    ctx.stroke();
  }
  
  // Check if we have data
  const allData = chartDataSide.concat(chartDataBottom, chartDataSidePower, chartDataBottomPower);
  if (!allData.length) {
    ctx.fillStyle = '#666';
    ctx.font = '14px sans-serif';
    ctx.fillText('Waiting for data...', margin + 10, margin + 20);
    return;
  }
  
  // Calculate min and max
  let minVal = Math.min(...allData);
  let maxVal = Math.max(...allData);
  if (minVal === maxVal) {
    minVal -= 1;
    maxVal += 1;
  }
  
  // Scale function
  const scaleY = (value) => margin + (plotHeight - ((value - minVal) / (maxVal - minVal)) * plotHeight);
  
  // Calculate x spacing for each dataset
  const spacingSide = plotWidth / Math.max(chartDataSide.length - 1, 1);
  const spacingBottom = plotWidth / Math.max(chartDataBottom.length - 1, 1);
  const spacingSidePower = plotWidth / Math.max(chartDataSidePower.length - 1, 1);
  const spacingBottomPower = plotWidth / Math.max(chartDataBottomPower.length - 1, 1);
  
  // Draw Side Temperature (red)
  ctx.strokeStyle = '#e74c3c';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < chartDataSide.length; i++) {
    const x = margin + i * spacingSide;
    const y = scaleY(chartDataSide[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw Bottom Temperature (blue)
  ctx.strokeStyle = '#3498db';
  ctx.beginPath();
  for (let i = 0; i < chartDataBottom.length; i++) {
    const x = margin + i * spacingBottom;
    const y = scaleY(chartDataBottom[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw Side Power (green)
  ctx.strokeStyle = '#2ecc71';
  ctx.beginPath();
  for (let i = 0; i < chartDataSidePower.length; i++) {
    const x = margin + i * spacingSidePower;
    const y = scaleY(chartDataSidePower[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw Bottom Power (orange)
  ctx.strokeStyle = '#f39c12';
  ctx.beginPath();
  for (let i = 0; i < chartDataBottomPower.length; i++) {
    const x = margin + i * spacingBottomPower;
    const y = scaleY(chartDataBottomPower[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Draw border
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 1;
  ctx.strokeRect(margin, margin, plotWidth, plotHeight);
  
  // Draw min/max labels
  ctx.fillStyle = '#666';
  ctx.font = '12px sans-serif';
  ctx.fillText(`min: ${minVal.toFixed(1)}`, 6, h - 8);
  ctx.fillText(`max: ${maxVal.toFixed(1)}`, 6, 16);
}

function addDataToChart(sideTemp, bottomTemp, totalPower) {
  // Get current switch time point from slider
  const switchTimeSliderElement = document.getElementById('switchTimeSlider');
  if (switchTimeSliderElement) {
    currentSwitchTimePoint = parseInt(switchTimeSliderElement.value);
  }
  
  // Get current calculated percent from display
  const calculatedPercentElement = document.getElementById('calculatedPercent');
  if (calculatedPercentElement) {
    currentCalculatedPercent = parseInt(calculatedPercentElement.textContent) || 50;
  }
  
  // Get current bottom wattage percent from slider
  const bottomWattagePercentSliderElement = document.getElementById('bottomWattagePercentSlider');
  if (bottomWattagePercentSliderElement) {
    currentBottomWattagePercent = parseInt(bottomWattagePercentSliderElement.value);
  }
  
  // Calculate side_power and bottom_power based on conditions
  let sidePower, bottomPower;
  
  if (currentCountdown != 0 && currentCountdown > currentSwitchTimePoint) {
    // Condition 1: Use Calculated Percentage
    sidePower = (currentCalculatedPercent / 100) * totalPower;
    bottomPower = ((100 - currentCalculatedPercent) / 100) * totalPower;
    console.log(`ğŸ’¡ Power calc mode 1: Countdown=${currentCountdown}s > SwitchTime=${currentSwitchTimePoint}s, using Calculated%=${currentCalculatedPercent}%`);
  } else {
    // Condition 2: Use Bottom Wattage Percent
    sidePower = ((100 - currentBottomWattagePercent) / 100) * totalPower;
    bottomPower = (currentBottomWattagePercent / 100) * totalPower;
    console.log(`ğŸ’¡ Power calc mode 2: Countdown=${currentCountdown}s <= SwitchTime=${currentSwitchTimePoint}s, using BottomWattage%=${currentBottomWattagePercent}%`);
  }
  
  console.log(`âš¡ Total Power: ${totalPower.toFixed(2)}W â†’ Side: ${sidePower.toFixed(2)}W, Bottom: ${bottomPower.toFixed(2)}W`);
  
  // Add data to arrays
  chartDataSide.push(sideTemp);
  chartDataBottom.push(bottomTemp);
  chartDataSidePower.push(sidePower);
  chartDataBottomPower.push(bottomPower);
  
  // Maintain max points limit
  if (chartDataSide.length > chartMaxPoints) chartDataSide.shift();
  if (chartDataBottom.length > chartMaxPoints) chartDataBottom.shift();
  if (chartDataSidePower.length > chartMaxPoints) chartDataSidePower.shift();
  if (chartDataBottomPower.length > chartMaxPoints) chartDataBottomPower.shift();
  
  // Update display
  set('curSide', sideTemp.toFixed(1));
  set('curBottom', bottomTemp);
  set('curSidePower', sidePower.toFixed(2));
  set('curBottomPower', bottomPower.toFixed(2));
  
  // Redraw chart
  drawChart();
  
  // Record data point with side_power and bottom_power
  recordDataPoint(sideTemp, bottomTemp, totalPower, sidePower, bottomPower);
}

document.getElementById('connectBtn').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['1011123e-8535-b5a0-7140-a304d2495cb7']
    });

    const server = await device.gatt.connect();
    const service = await server.getPrimaryService('1011123e-8535-b5a0-7140-a304d2495cb7');
    const characteristics = await service.getCharacteristics();

    for (const char of characteristics) {
      console.log('ç‰¹å¾å€¼ UUID:', char.uuid, 'Properties:', char.properties);
      if (char.properties.notify) {
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', event => {
          const d = new Uint8Array(event.target.value.buffer);
          
          // Print all received data in hex format
          const hexString = Array.from(d).map(byte => byte.toString(16).padStart(2, '0').toUpperCase()).join(' ');
          console.log(`ğŸ“© Received data (${d.length} bytes): ${hexString}`);
          
          /* ---------- AWK Detection ---------- */
          if (d.length === 3 && d[0] === 0x41 && d[1] === 0x57 && d[2] === 0x4B) {
            console.log('âœ… Received AWK');
            if (typeof ackResolver === 'function') {
              ackResolver();
              ackResolver = null;
            }
            return;
          }

          if (d[0] === 0xDD && d.length >= 17) {
            console.log('ğŸ“Š Processing 0xDD packet (Temperature data)');
            const sideTemp = ((d[3] << 8) | d[4]) * 9 / 5 + 32;
            const power = ((d[7] << 8) | d[8]) / 100;
            const bottomTemp = (d[15] << 8) | d[16];
            console.log(`  Side Temp: ${sideTemp.toFixed(2)}Â°F, Bottom Temp: ${bottomTemp}, Power: ${power.toFixed(2)}W`);
            addDataToChart(sideTemp, bottomTemp, power);
            return;
          }

          if (d.length < 16) {
            console.log('âš ï¸ Data too short, ignored');
            return;
          }
          
          if (d[0] != 0x99) {
            console.log('âš ï¸ Not a 0x99 packet, ignored');
            return;
          }
          
          console.log('ğŸ“‹ Processing 0x99 packet (Status data)');
          const byte2 = d[2];
          const byte3 = d[3];
          const byte4 = d[4];
          const byte5 = d[5];
          const temp = (d[6] << 8) | d[7];
          const dryTemp = (d[8] << 8) | d[9];
          const gessoTemp = (d[10] << 8) | d[11];
          const battery = d[12];
          const ledPreset = d[13] >> 4;
          const dryTime = d[14];
          const gessoTime = d[15];
          
          let presetTemp = 0;
          if(byte2 == 0x40)  presetTemp = dryTemp;
          if(byte2 == 0x60)  presetTemp = gessoTemp;
          if(byte2 == 0xA0)  presetTemp = dryTemp;
          if(byte2 == 0x30)  presetTemp = gessoTemp;

          const atomizerMap = {
            0x40: 'Gesso', 0x60: 'Gesso', 0xA0: 'Dry Herb', 0x30: 'Gesso Max', 0x00: 'No Atomizer'
          };
          const unitMap = {
            0x11: 'â„‰', 0x22: 'â„ƒ'
          };

          set('atomizer', atomizerMap[byte2] || `0x${byte2.toString(16)}`);
          set('dryPreset', byte4 >> 4);
          set('gessoPreset', byte4 & 0x0F);
          set('countdown', `${byte5}s`);
          
          // Update global countdown variable for power calculation
          currentCountdown = byte5;
          
          set('curTemp', temp + unitMap[byte3]);
          set('presetTemp', presetTemp + unitMap[byte3]);
          set('battery', `${battery}%`);
          set('ledPreset', ledPreset);
          set('dryTime', `${dryTime}s`);
          set('gessoTime', `${gessoTime}s`);
          
          console.log(`  Atomizer: ${atomizerMap[byte2] || '0x'+byte2.toString(16)}, Battery: ${battery}%, Temp: ${temp}, Countdown: ${byte5}s`);
        });
      }

      if (char.properties.write || char.properties.writeWithoutResponse) {
        characteristicToWrite = char;
        console.log('æ‰¾åˆ° Write ç‰¹å¾å€¼:', char.uuid);
      }
    }

    alert("è“ç‰™è®¾å¤‡è¿æ¥æˆåŠŸï¼");

  } catch (e) {
    alert('è¿æ¥å¤±è´¥: ' + e);
  }
});

document.getElementById('startWifiBtn').addEventListener('click', async () => {
  const ssid = document.getElementById('ssid').value;
  const password = document.getElementById('password').value;

  if (!ssid || !password) {
    alert("è¯·è¾“å…¥å®Œæ•´çš„ SSID å’Œå¯†ç ");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    const encoder = new TextEncoder();
    const ssidBytes = encoder.encode(ssid);
    const passwordBytes = encoder.encode(password);

    if (ssidBytes.length > 32 || passwordBytes.length > 64) {
      alert("SSID æˆ–å¯†ç è¿‡é•¿");
      return;
    }

    const data = new Uint8Array(1 + 1 + ssidBytes.length + 1 + passwordBytes.length);
    data[0] = 0xC0;
    data[1] = ssidBytes.length;
    data.set(ssidBytes, 2);
    data[2 + ssidBytes.length] = passwordBytes.length;
    data.set(passwordBytes, 3 + ssidBytes.length);

    await characteristicToWrite.writeValue(data);
    alert("WiFi ä¿¡æ¯å·²å‘é€");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});

document.getElementById('startOtaBtn').addEventListener('click', async () => {
  const otaUrl = document.getElementById('otaUrl').value.trim();
  
  if (!otaUrl) {
    alert("è¯·è¾“å…¥ OTA ä¸‹è½½ URL");
    return;
  }
  
  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }
  
  try {
    const encoder = new TextEncoder();
    const urlBytes = encoder.encode(otaUrl);
    
    if (urlBytes.length > 128) {
      alert("URL å¤ªé•¿ï¼ˆé™128å­—èŠ‚ï¼‰");
      return;
    }
    
    const data = new Uint8Array(1 + 1 + urlBytes.length);
    data[0] = 0xD0;
    data[1] = urlBytes.length;
    data.set(urlBytes, 2);
    
    await characteristicToWrite.writeValue(data);
    alert("OTA URL å·²å‘é€ï¼Œè®¾å¤‡å³å°†å¼€å§‹ä¸‹è½½å¹¶æ›´æ–°...");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});

document.getElementById('sendHexBtn').addEventListener('click', async () => {
  const hex = document.getElementById('hexInput').value.trim();
  if (!hex) {
    alert("è¯·è¾“å…¥åå…­è¿›åˆ¶æ•°æ®ï¼Œä¾‹å¦‚ï¼šAA 01 FF 00");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    const byteArray = hex.split(/\s+/).map(b => parseInt(b, 16));
    const data = new Uint8Array(byteArray);
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ Hex æ•°æ®");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});

document.getElementById('sendAsciiBtn').addEventListener('click', async () => {
  const asciiStr = document.getElementById('hexInput').value.trim();
  if (!asciiStr) {
    alert("è¯·è¾“å…¥ ASCII å­—ç¬¦ä¸²");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    const data = new TextEncoder().encode(asciiStr); // è½¬æˆ UTF-8 å­—èŠ‚æµ
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ ASCII å­—ç¬¦ä¸²");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});



/* ---------- å°åŒ…ï¼šè¿”å› Uint8Array( 518 ) ---------- */
const PAYLOAD_SIZE = 16;        // æ¯å¸§æœ‰æ•ˆæ•°æ® 32B
const FRAME_SIZE   = 22;   // 1+2+16+2+1
const HEADER_BYTE  = 0xAA;
const TAIL_BYTE    = 0xAA;
function crc16Modbus(buf) {
  let crc = 0xFFFF;
  for (let b of buf) {
    crc ^= b;
    for (let i = 0; i < 8; ++i)
      crc = (crc & 1) ? (crc >>> 1) ^ 0xA001 : crc >>> 1;
  }
  return crc & 0xFFFF;
}
function buildSmallPacket(seq, payload32) {
  const frame = new Uint8Array(FRAME_SIZE);

  frame[0] = HEADER_BYTE;           // å¸§å¤´
  frame[1] = seq & 0xFF;           // Seq_L
  frame[2] = (seq >> 8) & 0xFF;    // Seq_H

  frame.fill(0xFF, 3);             // å…ˆæŠŠ 32B åŒºåŸŸå¡« 0xFF
  frame.set(payload32, 3);         // å†™å…¥å®é™…æ•°æ®

  const crc = crc16Modbus(frame.subarray(1, 1 + 2 + PAYLOAD_SIZE)); // Seq+Payload
  frame[19] = (crc >> 8) & 0xFF;    // CRC é«˜
  frame[20] =  crc & 0xFF;          // CRC ä½
  frame[21] = TAIL_BYTE;            // å¸§å°¾

  return frame;
}





/* ---------- é€‰æ‹© BIN â†’ åˆ†åŒ… â†’ å†™å…¥ ---------- */
document.getElementById('sendBinBtn').addEventListener('click', async () => {
  const f = document.getElementById('binFile').files[0];
  if (!f) { alert('è¯·é€‰æ‹© .bin æ–‡ä»¶'); return; }
  if (!characteristicToWrite) { alert('è¯·å…ˆè¿æ¥è“ç‰™è®¾å¤‡'); return; }

  try {
    const arrayBuf = await f.arrayBuffer();
    let bin = new Uint8Array(arrayBuf);
    const realLength = bin.length; // åŸå§‹é•¿åº¦
    console.log(`ğŸ“¦ é€‰æ‹©çš„ OTA bin æ–‡ä»¶å¤§å°: ${realLength} å­—èŠ‚`);
    // âœ… è¡¥é½åˆ° 512 å­—èŠ‚å¯¹é½ï¼ˆä¸è¶³è¡¥ 0xFFï¼‰
    const padding = bin.length % 512;
    if (padding !== 0) {
      const padded = new Uint8Array(bin.length + (512 - padding)).fill(0xFF);
      padded.set(bin);
      bin = padded;
    }
    const totalBlocks = bin.length / 512; // 512 å­—èŠ‚ä¸ºä¸€ä¸ªå—
    const totalPkts = bin.length / PAYLOAD_SIZE; // 16 å­—èŠ‚æ¯åŒ…

    // âœ… å‘é€å¤´åŒ…ï¼š0x52 0x45 0x51 + len_L + len_H
    const header = new Uint8Array(9);
    header[0] = 0x52;
    header[1] = 0x45;
    header[2] = 0x51;
    header[3] = (totalBlocks >> 8) & 0xFF;
    header[4] = totalBlocks & 0xFF;

    header[5] = (realLength >> 24) & 0xFF;
    header[6] = (realLength >> 16) & 0xFF;
    header[7] = (realLength >> 8) & 0xFF;
    header[8] = realLength & 0xFF;

    console.log(`ğŸ“¦ å‘é€ REQ åŒ…ï¼Œæ€»å—æ•°: ${totalBlocks}, å®é™…å­—èŠ‚æ•°: ${realLength}`);
    await characteristicToWrite.writeValue(header);
    try {
      await waitForAck();  // ç­‰è®¾å¤‡ ACK
      console.log("âœ… æ”¶åˆ° ACKï¼Œå¼€å§‹å‘é€æ•°æ®...");
    } catch (e) {
      alert("REQ é˜¶æ®µå¤±è´¥: " + e.message);
      return;
    }




    const BATCH_SIZE = 32;  // æ¯ N åŒ…ç­‰ä¸€æ¬¡ ACK

    for (let offset = 0, seq = 0; offset < bin.length; offset += PAYLOAD_SIZE, ++seq) {
      const remain = bin.length - offset;
      const block32 = remain >= PAYLOAD_SIZE
            ? bin.subarray(offset, offset + PAYLOAD_SIZE)
            : new Uint8Array(PAYLOAD_SIZE).fill(0xFF)
                  .map((v, i) => (i < remain ? bin[offset + i] : v));

      const pkt = buildSmallPacket(seq, block32);
      console.log(`Sending pkt data pkt=${pkt}, seq=${seq}, size=${pkt.length}, remain=${remain}`);
      await characteristicToWrite.writeValue(pkt);

      if ((seq + 1) % BATCH_SIZE === 0 || (offset + PAYLOAD_SIZE) >= bin.length) {
        console.log(`ğŸ• Batch ${seq + 1} sent, waiting for ACK...`);
        try {
          await waitForAck();  // æ¯32å¸§ç­‰ä¸€æ¬¡ AWK
        } catch (e) {
          alert(e.message);
          return;
        }
      }
    }


      alert('OTA bin å…¨éƒ¨å‘é€å®Œæˆï¼');
    } 
  catch (e) {
    alert('å‘é€å¤±è´¥: ' + e.message);
  }
});



window.addEventListener('DOMContentLoaded', () => {
  const otaInput = document.getElementById('otaUrl');
  otaInput.value = `${location.origin}/simple_ota.bin`;
  drawChart();
  
  // Power slider elements
  const wattageSideSlider = document.getElementById('wattageSideSlider');
  const wattageBottomSlider = document.getElementById('wattageBottomSlider');
  const wattageSideValue = document.getElementById('wattageSideValue');
  const wattageBottomValue = document.getElementById('wattageBottomValue');
  const calculatedPercent = document.getElementById('calculatedPercent');
  const totalWattage = document.getElementById('totalWattage');
  const sendWattageBtn = document.getElementById('sendWattageBtn');
  
  // New slider elements
  const bottomWattagePercentSlider = document.getElementById('bottomWattagePercentSlider');
  const bottomWattagePercentValue = document.getElementById('bottomWattagePercentValue');
  const switchTimeSlider = document.getElementById('switchTimeSlider');
  const switchTimeValue = document.getElementById('switchTimeValue');
  
  // Button elements
  const sideMinusBtn = document.getElementById('sideMinusBtn');
  const sidePlusBtn = document.getElementById('sidePlusBtn');
  const bottomMinusBtn = document.getElementById('bottomMinusBtn');
  const bottomPlusBtn = document.getElementById('bottomPlusBtn');
  const bottomPercentMinusBtn = document.getElementById('bottomPercentMinusBtn');
  const bottomPercentPlusBtn = document.getElementById('bottomPercentPlusBtn');
  const switchTimeMinusBtn = document.getElementById('switchTimeMinusBtn');
  const switchTimePlusBtn = document.getElementById('switchTimePlusBtn');
  
  // Maximum total power limit
  const MAX_TOTAL_WATTAGE = 60;
  
  // Calculate percentage function
  function calculatePercent() {
    const sideW = parseInt(wattageSideSlider.value);
    const bottomW = parseInt(wattageBottomSlider.value);
    const total = sideW + bottomW;
    
    if (total === 0) {
      return 0;
    }
    
    const percent = Math.round((sideW / total) * 100);
    return percent;
  }
  
  // Update display function
  function updateDisplay() {
    wattageSideValue.textContent = wattageSideSlider.value;
    wattageBottomValue.textContent = wattageBottomSlider.value;
    
    const total = parseInt(wattageSideSlider.value) + parseInt(wattageBottomSlider.value);
    totalWattage.textContent = total;
    
    // Change color based on total power
    if (total > MAX_TOTAL_WATTAGE) {
      totalWattage.style.color = '#dc3545'; // Red
    } else if (total === MAX_TOTAL_WATTAGE) {
      totalWattage.style.color = '#ffc107'; // Yellow
    } else {
      totalWattage.style.color = '#28a745'; // Green
    }
    
    calculatedPercent.textContent = calculatePercent();
    bottomWattagePercentValue.textContent = bottomWattagePercentSlider.value;
    switchTimeValue.textContent = switchTimeSlider.value;
  }
  
  // Update Bottom slider max value
  function updateBottomMax() {
    const sideW = parseInt(wattageSideSlider.value);
    const maxBottom = MAX_TOTAL_WATTAGE - sideW;
    wattageBottomSlider.max = maxBottom;
    
    // Adjust if current Bottom value exceeds new max
    if (parseInt(wattageBottomSlider.value) > maxBottom) {
      wattageBottomSlider.value = maxBottom;
    }
  }
  
  // Update Side slider max value
  function updateSideMax() {
    const bottomW = parseInt(wattageBottomSlider.value);
    const maxSide = MAX_TOTAL_WATTAGE - bottomW;
    wattageSideSlider.max = maxSide;
    
    // å¦‚æœå½“å‰ Side å€¼è¶…è¿‡æ–°çš„æœ€å¤§å€¼ï¼Œè‡ªåŠ¨è°ƒæ•´
    if (parseInt(wattageSideSlider.value) > maxSide) {
      wattageSideSlider.value = maxSide;
    }
  }
  
  // Side æ»‘åŠ¨æ¡äº‹ä»¶
  wattageSideSlider.addEventListener('input', () => {
    updateBottomMax(); // æ›´æ–° Bottom çš„æœ€å¤§å€¼
    updateDisplay();
  });
  
  // Bottom æ»‘åŠ¨æ¡äº‹ä»¶
  wattageBottomSlider.addEventListener('input', () => {
    updateSideMax(); // æ›´æ–° Side çš„æœ€å¤§å€¼
    updateDisplay();
  });
  
  // Side - æŒ‰é’®
  sideMinusBtn.addEventListener('click', () => {
    let v = parseInt(wattageSideSlider.value) || 0;
    if (v > 0) v -= 1;
    wattageSideSlider.value = v;
    updateBottomMax();
    updateDisplay();
  });
  
  // Side + æŒ‰é’®
  sidePlusBtn.addEventListener('click', () => {
    let v = parseInt(wattageSideSlider.value) || 0;
    const bottomW = parseInt(wattageBottomSlider.value);
    const maxSide = MAX_TOTAL_WATTAGE - bottomW;
    
    if (v < maxSide) {
      v += 1;
      wattageSideSlider.value = v;
      updateBottomMax();
      updateDisplay();
    }
  });
  
  // Bottom - æŒ‰é’®
  bottomMinusBtn.addEventListener('click', () => {
    let v = parseInt(wattageBottomSlider.value) || 0;
    if (v > 0) v -= 1;
    wattageBottomSlider.value = v;
    updateSideMax();
    updateDisplay();
  });
  
  // Bottom + button
  bottomPlusBtn.addEventListener('click', () => {
    let v = parseInt(wattageBottomSlider.value) || 0;
    const sideW = parseInt(wattageSideSlider.value);
    const maxBottom = MAX_TOTAL_WATTAGE - sideW;
    
    if (v < maxBottom) {
      v += 1;
      wattageBottomSlider.value = v;
      updateSideMax();
      updateDisplay();
    }
  });
  
  // Bottom Wattage Percent slider event
  bottomWattagePercentSlider.addEventListener('input', () => {
    updateDisplay();
  });
  
  // Bottom Percent - button
  bottomPercentMinusBtn.addEventListener('click', () => {
    let v = parseInt(bottomWattagePercentSlider.value) || 0;
    if (v > 0) v -= 1;
    bottomWattagePercentSlider.value = v;
    updateDisplay();
  });
  
  // Bottom Percent + button
  bottomPercentPlusBtn.addEventListener('click', () => {
    let v = parseInt(bottomWattagePercentSlider.value) || 0;
    if (v < 100) v += 1;
    bottomWattagePercentSlider.value = v;
    updateDisplay();
  });
  
  // Switch Time slider event
  switchTimeSlider.addEventListener('input', () => {
    updateDisplay();
  });
  
  // Switch Time - button
  switchTimeMinusBtn.addEventListener('click', () => {
    let v = parseInt(switchTimeSlider.value) || 0;
    if (v > 0) v -= 1;
    switchTimeSlider.value = v;
    updateDisplay();
  });
  
  // Switch Time + button
  switchTimePlusBtn.addEventListener('click', () => {
    let v = parseInt(switchTimeSlider.value) || 0;
    if (v < 60) v += 1;
    switchTimeSlider.value = v;
    updateDisplay();
  });
  
  // Send data button
  sendWattageBtn.addEventListener('click', async () => {
    const sideW = parseInt(wattageSideSlider.value);
    const bottomW = parseInt(wattageBottomSlider.value);
    const total = sideW + bottomW;
    
    // Check if total power exceeds limit
    if (total > MAX_TOTAL_WATTAGE) {
      alert(`Error: Total power ${total}W exceeds limit ${MAX_TOTAL_WATTAGE}W!\nPlease adjust power settings.`);
      return;
    }
    
    if (total === 0) {
      alert('Error: Total power cannot be 0W!');
      return;
    }
    
    const percent = calculatePercent();
    const bottomWattagePercent = parseInt(bottomWattagePercentSlider.value);
    const switchTimePoint = parseInt(switchTimeSlider.value);
    
    if (!characteristicToWrite) {
      alert('Bluetooth device not connected or writable characteristic not found');
      return;
    }
    
    try {
      // Send B1 command first: B1 06 percent bottomWattagePercent switchTimePoint B1
      const data = new Uint8Array([0xB1, 0x06, percent, bottomWattagePercent, switchTimePoint, 0xB1]);
      await characteristicToWrite.writeValue(data);
      console.log(`Power data sent: Side=${sideW}W, Bottom=${bottomW}W, Total=${total}W, Percent=${percent}%, BottomWattagePercent=${bottomWattagePercent}%, SwitchTime=${switchTimePoint}s`);
      console.log(`Bluetooth packet: B1 06 ${percent.toString(16).padStart(2, '0').toUpperCase()} ${bottomWattagePercent.toString(16).padStart(2, '0').toUpperCase()} ${switchTimePoint.toString(16).padStart(2, '0').toUpperCase()} B1`);
      
      // Wait 200ms before sending CF command
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Calculate TotalPower * 10
      const totalPowerTimes10 = total * 10;
      const highByte = (totalPowerTimes10 >> 8) & 0xFF;
      const lowByte = totalPowerTimes10 & 0xFF;
      
      // Send CF command: CF 0B TotalPower*10(high) TotalPower*10(low) 01 F4 00 96 00 14 CF
      const cfData = new Uint8Array([0xCF, 0x0B, highByte, lowByte, 0x01, 0xF4, 0x00, 0x96, 0x00, 0x14, 0xCF]);
      await characteristicToWrite.writeValue(cfData);
      console.log(`CF command sent: Total=${total}W, TotalPower*10=${totalPowerTimes10}`);
      console.log(`Bluetooth packet: CF 0B ${highByte.toString(16).padStart(2, '0').toUpperCase()} ${lowByte.toString(16).padStart(2, '0').toUpperCase()} 01 F4 00 96 00 14 CF`);
      
      alert(`âœ… Sent successfully!\n\nSide: ${sideW}W\nBottom: ${bottomW}W\nTotal Power: ${total}W\nPercentage: ${percent}%\nBottom Wattage %: ${bottomWattagePercent}%\nSwitch Time: ${switchTimePoint}s\n\nCommands sent:\n1. B1 06 ${percent.toString(16).padStart(2, '0').toUpperCase()} ${bottomWattagePercent.toString(16).padStart(2, '0').toUpperCase()} ${switchTimePoint.toString(16).padStart(2, '0').toUpperCase()} B1\n2. CF 0B ${highByte.toString(16).padStart(2, '0').toUpperCase()} ${lowByte.toString(16).padStart(2, '0').toUpperCase()} 01 F4 00 96 00 14 CF`);
    } catch (e) {
      alert('Send failed: ' + e.message);
    }
  });
  
  // Initialize display
  updateBottomMax();
  updateSideMax();
  updateDisplay();
});


</script>

</body>
</html>