<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluetooth Device Status Panel</title>
  <style>
    body { font-family: sans-serif; background: #f8fbff; padding: 2em; }
    h2 { margin-bottom: 1em; }
    .panel { background: #fff; padding: 1em; border-radius: 10px; box-shadow: 0 0 6px #ccc; max-width: 500px; }
    .row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #ddd; }
    .row:last-child { border: none; }
    label { font-weight: bold; }
    .val { font-family: monospace; }
    button, input { margin: 0.5em 0; padding: 0.6em; font-size: 1em; }
    .form { margin-top: 1em; }
  </style>
</head>
<body>

<h2>ğŸ“¡ Bluetooth Status Panel</h2>
<button id="connectBtn">ğŸ”— Connect Bluetooth Device</button>

<div class="form">
  <label for="ssid">SSID:</label>
  <input type="text" id="ssid" placeholder="Enter WiFi SSID">
  <label for="password">Password:</label>
  <input type="text" id="password" placeholder="Enter WiFi password">
  <button id="startWifiBtn">ğŸš€ Start WiFi</button>

  <!-- OTA BIN Upload -->
  <div style="margin-top:1em;">
    <label for="binFile">Select OTA Firmware (.bin):</label>
    <input type="file" id="binFile" accept=".bin">
    <button id="sendBinBtn">ğŸ“¦ Send OTA BIN</button>
  </div>

  <!-- OTA URL Input -->
  <div style="margin-top: 1em;">
  <label for="otaUrl">OTA URL:</label>
  <input type="text" id="otaUrl" placeholder="Enter OTA download URL" style="width: 50%;">
  <button id="startOtaBtn">â¬‡ï¸ Start WiFi OTA</button>
  </div>

  <div class="form">
  <label for="hexInput">Send Hex Data Manually:</label>
  <input type="text" id="hexInput" placeholder="e.g. AA 01 FF 00" style="width: 60%;">
  <button id="sendHexBtn">ğŸ“¤ Send Hex</button>
  <button id="sendAsciiBtn">ğŸ“ Send ASCII</button>
  </div>

  <!-- Percentage Slider -->
  <div class="form">
  <label for="percentSlider">Percentage Control (0-100):</label>
  <input type="range" id="percentSlider" min="0" max="100" value="50" style="width: 60%;">
  <span id="percentValue">50</span>%
  </div>

</div>

<div class="panel" id="statusPanel">
  <div class="row"><label>Atomizer Type:</label><span class="val" id="atomizer">--</span></div>
  <div class="row"><label>Dry Herb Preset:</label><span class="val" id="dryPreset">--</span></div>
  <div class="row"><label>Gesso Preset:</label><span class="val" id="gessoPreset">--</span></div>
  <div class="row"><label>Countdown:</label><span class="val" id="countdown">--</span></div>
  <div class="row"><label>Current Temp:</label><span class="val" id="curTemp">--</span></div>
  <div class="row"><label>Preset Temp:</label><span class="val" id="presetTemp">--</span></div>
  <div class="row"><label>Battery Level:</label><span class="val" id="battery">--</span></div>
  <div class="row"><label>LED Preset:</label><span class="val" id="ledPreset">--</span></div>
  <div class="row"><label>Dry Herb Time:</label><span class="val" id="dryTime">--</span></div>
  <div class="row"><label>Gesso Time:</label><span class="val" id="gessoTime">--</span></div>
</div>

<script>
let characteristicToWrite = null; // ä¿å­˜å¯å†™ç‰¹å¾å€¼


/* ç­‰å¾…è®¾å¤‡è¿”å› AWKï¼ˆ41 57 4Bï¼‰ï¼Œå¸¦è¶…æ—¶ */
function waitForAck(timeout = 6000) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      console.warn("âš ï¸ ACK è¶…æ—¶ï¼Œæœªæ”¶åˆ°è®¾å¤‡å“åº”");
      reject(new Error("ç­‰å¾… AWK è¶…æ—¶"));
    }, timeout);

    // ä¿å­˜ä¸€ä¸ªè§¦å‘å™¨åˆ°å…¨å±€ï¼Œæ”¶åˆ° AWK æ—¶ä¼šè°ƒç”¨å®ƒ
    ackResolver = () => {
      clearTimeout(timer);
      resolve();
    };
  });
}


function set(id, value) {
  document.getElementById(id).textContent = value;
}

document.getElementById('connectBtn').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['1011123e-8535-b5a0-7140-a304d2495cb7']
    });

    const server = await device.gatt.connect();
    const service = await server.getPrimaryService('1011123e-8535-b5a0-7140-a304d2495cb7');
    const characteristics = await service.getCharacteristics();

    for (const char of characteristics) {
      console.log('ç‰¹å¾å€¼ UUID:', char.uuid, 'Properties:', char.properties);
      if (char.properties.notify) {
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', event => {
          const d = new Uint8Array(event.target.value.buffer);
          /* ---------- AWK æ£€æµ‹ ---------- */
          if (d.length === 3 && d[0] === 0x41 && d[1] === 0x57 && d[2] === 0x4B) {
            console.log('âœ… æ”¶åˆ° AWK');
            if (typeof ackResolver === 'function') {
              ackResolver();
              ackResolver = null;
            }
            return;
          }

          if(d[0] != 0x99) {
            console.log('æ”¶åˆ° Notify æ•°æ®:', d);
          }
          


          if (d.length < 16) return;
          if (d[0] != 0x99)  return;
          const byte2 = d[2];
          const byte3 = d[3];
          const byte4 = d[4];
          const byte5 = d[5];
          const temp = (d[6] << 8) | d[7];
          const dryTemp = (d[8] << 8) | d[9];
          const gessoTemp = (d[10] << 8) | d[11];
          const battery = d[12];
          const ledPreset = d[13] >> 4;
          const dryTime = d[14];
          const gessoTime = d[15];
          
          let presetTemp = 0;
          if(byte2 == 0x40)  presetTemp = dryTemp;
          if(byte2 == 0x60)  presetTemp = gessoTemp;
          if(byte2 == 0xA0)  presetTemp = dryTemp;
          if(byte2 == 0x30)  presetTemp = gessoTemp;

          const atomizerMap = {
            0x40: 'Gesso', 0x60: 'Gesso', 0xA0: 'Dry Herb', 0x30: 'Gesso Max', 0x00: 'No Atomizer'
          };
          const unitMap = {
            0x11: 'â„‰', 0x22: 'â„ƒ'
          };

          set('atomizer', atomizerMap[byte2] || `0x${byte2.toString(16)}`);
          set('dryPreset', byte4 >> 4);
          set('gessoPreset', byte4 & 0x0F);
          set('countdown', `${byte5}s`);
          set('curTemp', temp + unitMap[byte3]);
          set('presetTemp', presetTemp + unitMap[byte3]);
          set('battery', `${battery}%`);
          set('ledPreset', ledPreset);
          set('dryTime', `${dryTime}s`);
          set('gessoTime', `${gessoTime}s`);
          console.log('æ‰¾åˆ° Notify ç‰¹å¾å€¼:', char.uuid);
        });
      }

      if (char.properties.write || char.properties.writeWithoutResponse) {
        characteristicToWrite = char;
        console.log('æ‰¾åˆ° Write ç‰¹å¾å€¼:', char.uuid);
      }
    }

    alert("è“ç‰™è®¾å¤‡è¿æ¥æˆåŠŸï¼");

  } catch (e) {
    alert('è¿æ¥å¤±è´¥: ' + e);
  }
});

document.getElementById('startWifiBtn').addEventListener('click', async () => {
  const ssid = document.getElementById('ssid').value.trim();
  const password = document.getElementById('password').value.trim();
  if (!ssid) {
    alert("è¯·è¾“å…¥ SSID");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼ï¼Œè¯·å…ˆè¿æ¥è®¾å¤‡");
    return;
  }

  const data = new TextEncoder().encode(`wifi_${ssid} ${password}`);
  try {
    await characteristicToWrite.writeValue(data);
    alert("WiFi é…ç½®å·²å‘é€");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e);
  }
});

// ğŸŒŸ æ–°å¢: å¤„ç† Start OTA æŒ‰é’®ç‚¹å‡»
document.getElementById('startOtaBtn').addEventListener('click', async () => {
  const otaUrl = document.getElementById('otaUrl').value.trim();
  if (!otaUrl) {
    alert("è¯·è¾“å…¥ OTA ä¸‹è½½ URL");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼ï¼Œè¯·å…ˆè¿æ¥è®¾å¤‡");
    return;
  }

  const data = new TextEncoder().encode(`url_${otaUrl}`);
  try {
    await characteristicToWrite.writeValue(data);
    alert("OTA åœ°å€å·²å‘é€");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e);
  }
});

document.getElementById('sendHexBtn').addEventListener('click', async () => {
  const hexStr = document.getElementById('hexInput').value.trim();
  if (!hexStr) {
    alert("è¯·è¾“å…¥åå…­è¿›åˆ¶æ•°æ®");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Uint8Array
    const hexArray = hexStr.split(/\s+/).map(byte => {
      const num = parseInt(byte, 16);
      if (isNaN(num)) throw new Error(`æ— æ•ˆçš„åå…­è¿›åˆ¶æ•°: ${byte}`);
      return num;
    });
    const data = new Uint8Array(hexArray);
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ Hex æ•°æ®");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});
document.getElementById('sendAsciiBtn').addEventListener('click', async () => {
  const asciiStr = document.getElementById('hexInput').value.trim();
  if (!asciiStr) {
    alert("è¯·è¾“å…¥ ASCII å­—ç¬¦ä¸²");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    const data = new TextEncoder().encode(asciiStr); // è½¬æˆ UTF-8 å­—èŠ‚æµ
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ ASCII å­—ç¬¦ä¸²");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});



/* ---------- å°åŒ…ï¼šè¿”å› Uint8Array( 518 ) ---------- */
const PAYLOAD_SIZE = 16;        // æ¯å¸§æœ‰æ•ˆæ•°æ® 32B
const FRAME_SIZE   = 22;   // 1+2+16+2+1
const HEADER_BYTE  = 0xAA;
const TAIL_BYTE    = 0xAA;
function crc16Modbus(buf) {
  let crc = 0xFFFF;
  for (let b of buf) {
    crc ^= b;
    for (let i = 0; i < 8; ++i)
      crc = (crc & 1) ? (crc >>> 1) ^ 0xA001 : crc >>> 1;
  }
  return crc & 0xFFFF;
}
function buildSmallPacket(seq, payload32) {
  const frame = new Uint8Array(FRAME_SIZE);

  frame[0] = HEADER_BYTE;           // å¸§å¤´
  frame[1] = seq & 0xFF;           // Seq_L
  frame[2] = (seq >> 8) & 0xFF;    // Seq_H

  frame.fill(0xFF, 3);             // å…ˆæŠŠ 32B åŒºåŸŸå¡« 0xFF
  frame.set(payload32, 3);         // å†™å…¥å®é™…æ•°æ®

  const crc = crc16Modbus(frame.subarray(1, 1 + 2 + PAYLOAD_SIZE)); // Seq+Payload
  frame[19] = (crc >> 8) & 0xFF;    // CRC é«˜
  frame[20] =  crc & 0xFF;          // CRC ä½
  frame[21] = TAIL_BYTE;            // å¸§å°¾

  return frame;
}





/* ---------- é€‰æ‹© BIN â†’ åˆ†åŒ… â†’ å†™å…¥ ---------- */
document.getElementById('sendBinBtn').addEventListener('click', async () => {
  const f = document.getElementById('binFile').files[0];
  if (!f) { alert('è¯·é€‰æ‹© .bin æ–‡ä»¶'); return; }
  if (!characteristicToWrite) { alert('è¯·å…ˆè¿æ¥è“ç‰™è®¾å¤‡'); return; }

  try {
    const arrayBuf = await f.arrayBuffer();
    let bin = new Uint8Array(arrayBuf);
    const realLength = bin.length; // åŸå§‹é•¿åº¦
    console.log(`ğŸ“¦ é€‰æ‹©çš„ OTA bin æ–‡ä»¶å¤§å°: ${realLength} å­—èŠ‚`);
    // âœ… è¡¥é½åˆ° 512 å­—èŠ‚å¯¹é½ï¼ˆä¸è¶³è¡¥ 0xFFï¼‰
    const padding = bin.length % 512;
    if (padding !== 0) {
      const padded = new Uint8Array(bin.length + (512 - padding)).fill(0xFF);
      padded.set(bin);
      bin = padded;
    }
    const totalBlocks = bin.length / 512; // 512 å­—èŠ‚ä¸ºä¸€ä¸ªå—
    const totalPkts = bin.length / PAYLOAD_SIZE; // 16 å­—èŠ‚æ¯åŒ…

    // âœ… å‘é€å¤´åŒ…ï¼š0x52 0x45 0x51 + len_L + len_H
    const header = new Uint8Array(9);
    header[0] = 0x52;
    header[1] = 0x45;
    header[2] = 0x51;
    header[3] = (totalBlocks >> 8) & 0xFF;
    header[4] = totalBlocks & 0xFF;

    header[5] = (realLength >> 24) & 0xFF;
    header[6] = (realLength >> 16) & 0xFF;
    header[7] = (realLength >> 8) & 0xFF;
    header[8] = realLength & 0xFF;

    console.log(`ğŸ“¦ å‘é€ REQ åŒ…ï¼Œæ€»å—æ•°: ${totalBlocks}, å®é™…å­—èŠ‚æ•°: ${realLength}`);
    await characteristicToWrite.writeValue(header);
    try {
      await waitForAck();  // ç­‰è®¾å¤‡ ACK
      console.log("âœ… æ”¶åˆ° ACKï¼Œå¼€å§‹å‘é€æ•°æ®...");
    } catch (e) {
      alert("REQ é˜¶æ®µå¤±è´¥: " + e.message);
      return;
    }




    const BATCH_SIZE = 32;  // æ¯ N åŒ…ç­‰ä¸€æ¬¡ ACK

    for (let offset = 0, seq = 0; offset < bin.length; offset += PAYLOAD_SIZE, ++seq) {
      const remain = bin.length - offset;
      const block32 = remain >= PAYLOAD_SIZE
            ? bin.subarray(offset, offset + PAYLOAD_SIZE)
            : new Uint8Array(PAYLOAD_SIZE).fill(0xFF)
                  .map((v, i) => (i < remain ? bin[offset + i] : v));

      const pkt = buildSmallPacket(seq, block32);
      console.log(`Sending pkt data pkt=${pkt}, seq=${seq}, size=${pkt.length}, remain=${remain}`);
      await characteristicToWrite.writeValue(pkt);

      if ((seq + 1) % BATCH_SIZE === 0 || (offset + PAYLOAD_SIZE) >= bin.length) {
        console.log(`ğŸ• Batch ${seq + 1} sent, waiting for ACK...`);
        try {
          await waitForAck();  // æ¯32å¸§ç­‰ä¸€æ¬¡ AWK
        } catch (e) {
          alert(e.message);
          return;
        }
      }
    }


      alert('OTA bin å…¨éƒ¨å‘é€å®Œæˆï¼');
    } 
  catch (e) {
    alert('å‘é€å¤±è´¥: ' + e.message);
  }
});



window.addEventListener('DOMContentLoaded', () => {
  const otaInput = document.getElementById('otaUrl');
  otaInput.value = `${location.origin}/simple_ota.bin`;
  
  // æ»‘åŠ¨æ¡äº‹ä»¶å¤„ç†
  const percentSlider = document.getElementById('percentSlider');
  const percentValue = document.getElementById('percentValue');
  
  // å®æ—¶æ›´æ–°æ˜¾ç¤ºå€¼
  percentSlider.addEventListener('input', () => {
    percentValue.textContent = percentSlider.value;
  });
  
  // æ»‘åŠ¨å®Œæˆåå‘é€è“ç‰™æ•°æ®
  percentSlider.addEventListener('change', async () => {
    const percent = parseInt(percentSlider.value);
    
    if (!characteristicToWrite) {
      alert('æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼');
      return;
    }
    
    try {
      // æ„å»ºæ•°æ®åŒ…: B1 04 percent B1
      const data = new Uint8Array([0xB1, 0x04, percent, 0xB1]);
      await characteristicToWrite.writeValue(data);
      console.log(`å·²å‘é€ç™¾åˆ†æ¯”æ•°æ®: B1 04 ${percent.toString(16).padStart(2, '0').toUpperCase()} B1`);
    } catch (e) {
      alert('å‘é€å¤±è´¥: ' + e.message);
    }
  });
});


</script>

</body>
</html>
