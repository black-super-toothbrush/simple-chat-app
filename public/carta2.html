<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>è“ç‰™è®¾å¤‡çŠ¶æ€é¢æ¿</title>
  <style>
    body { font-family: sans-serif; background: #f8fbff; padding: 2em; }
    h2 { margin-bottom: 1em; }
    .panel { background: #fff; padding: 1em; border-radius: 10px; box-shadow: 0 0 6px #ccc; max-width: 500px; }
    .row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #ddd; }
    .row:last-child { border: none; }
    label { font-weight: bold; }
    .val { font-family: monospace; }
    button, input { margin: 0.5em 0; padding: 0.6em; font-size: 1em; }
    .form { margin-top: 1em; }
  </style>
</head>
<body>

<h2>ğŸ“¡ è“ç‰™çŠ¶æ€é¢æ¿</h2>
<button id="connectBtn">ğŸ”— è¿æ¥è“ç‰™è®¾å¤‡</button>

<div class="form">
  <label for="ssid">SSID:</label>
  <input type="text" id="ssid" placeholder="è¯·è¾“å…¥WiFi SSID">
  <label for="password">Password:</label>
  <input type="text" id="password" placeholder="è¯·è¾“å…¥WiFiå¯†ç ">
  <button id="startWifiBtn">ğŸš€ Start WiFi</button>

  <!--  OTA BIN å‘é€  -->
  <div style="margin-top:1em;">
    <label for="binFile">é€‰æ‹© OTA å›ºä»¶ (.bin):</label>
    <input type="file" id="binFile" accept=".bin">
    <button id="sendBinBtn">ğŸ“¦ å‘é€ OTA BIN</button>
  </div>

  <!-- ğŸŒŸ æ–°å¢ OTA åœ°å€è¾“å…¥ -->
  <div style="margin-top: 1em;">
  <label for="otaUrl">OTAåœ°å€:</label>
  <input type="text" id="otaUrl" placeholder="è¯·è¾“å…¥OTAä¸‹è½½URL" style="width: 50%;">
  <button id="startOtaBtn">â¬‡ï¸ Start Wifi OTA</button>
  </div>

  <div class="form">
  <label for="hexInput">æ‰‹åŠ¨å‘é€åå…­è¿›åˆ¶æ•°æ®:</label>
  <input type="text" id="hexInput" placeholder="ä¾‹å¦‚: AA 01 FF 00" style="width: 60%;">
  <button id="sendHexBtn">ğŸ“¤ å‘é€ Hex æ•°æ®</button>
  <button id="sendAsciiBtn">ğŸ“ å‘é€ ASCII å­—ç¬¦ä¸²</button>
  </div>

</div>

<div class="panel" id="statusPanel">
  <div class="row"><label>é›¾åŒ–å™¨ç±»å‹:</label><span class="val" id="atomizer">--</span></div>
  <div class="row"><label>Dry Herb Preset:</label><span class="val" id="dryPreset">--</span></div>
  <div class="row"><label>Gesso Preset:</label><span class="val" id="gessoPreset">--</span></div>
  <div class="row"><label>å€’è®¡æ—¶:</label><span class="val" id="countdown">--</span></div>
  <div class="row"><label>å½“å‰æ¸©åº¦:</label><span class="val" id="curTemp">--</span></div>
  <div class="row"><label>é¢„è®¾æ¸©åº¦:</label><span class="val" id="presetTemp">--</span></div>
  <div class="row"><label>ç”µæ± ç”µé‡:</label><span class="val" id="battery">--</span></div>
  <div class="row"><label>LED Preset:</label><span class="val" id="ledPreset">--</span></div>
  <div class="row"><label>Dry Herb Time:</label><span class="val" id="dryTime">--</span></div>
  <div class="row"><label>Gesso Time:</label><span class="val" id="gessoTime">--</span></div>
</div>

<script>
let characteristicToWrite = null; // ä¿å­˜å¯å†™ç‰¹å¾å€¼


let ackResolver = null;    // ä¿å­˜æœ¬è½®ç­‰å¾… ACK çš„ resolve
const ACK_TIMEOUT = 6000;  // æ¯«ç§’ï¼Œå¯æŒ‰éœ€è°ƒæ•´

/* ç­‰å¾…è®¾å¤‡è¿”å› AWKï¼ˆ41 57 4Bï¼‰ï¼Œå¸¦è¶…æ—¶ */
function waitForAck() {
  return new Promise((resolve, reject) => {
    ackResolver = resolve;                 // æ”¶åˆ° AWK æ—¶ä¼šè°ƒç”¨ resolve()
    setTimeout(() => {
      if (ackResolver) {                   // è¶…æ—¶ä»æœªæ”¶åˆ°
        ackResolver = null;
        reject(new Error('ç­‰å¾… AWK è¶…æ—¶'));
      }
    }, ACK_TIMEOUT);
  });
}


function set(id, value) {
  document.getElementById(id).textContent = value;
}

document.getElementById('connectBtn').addEventListener('click', async () => {
  try {
    const device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['1011123e-8535-b5a0-7140-a304d2495cb7']
    });

    const server = await device.gatt.connect();
    const service = await server.getPrimaryService('1011123e-8535-b5a0-7140-a304d2495cb7');
    const characteristics = await service.getCharacteristics();

    for (const char of characteristics) {
      console.log('ç‰¹å¾å€¼ UUID:', char.uuid, 'Properties:', char.properties);
      if (char.properties.notify) {
        await char.startNotifications();
        char.addEventListener('characteristicvaluechanged', event => {
          const d = new Uint8Array(event.target.value.buffer);
          /* ---------- AWK æ£€æµ‹ ---------- */
          if (d.length === 3 && d[0] === 0x41 && d[1] === 0x57 && d[2] === 0x4B) {
            console.log('æ”¶åˆ° AWK');
            if (ackResolver) { ackResolver(); ackResolver = null; }
            return;           // å¤„ç†å®Œ AWK åç›´æ¥è¿”å›ï¼Œä¸‹é¢è§£æå¸§å¯é€‰
          }

          if(d[0] != 0x99) {
            console.log('æ”¶åˆ° Notify æ•°æ®:', d);
          }
          


          if (d.length < 16) return;
          if (d[0] != 0x99)  return;
          const byte2 = d[2];
          const byte3 = d[3];
          const byte4 = d[4];
          const byte5 = d[5];
          const temp = (d[6] << 8) | d[7];
          const dryTemp = (d[8] << 8) | d[9];
          const gessoTemp = (d[10] << 8) | d[11];
          const battery = d[12];
          const ledPreset = d[13] >> 4;
          const dryTime = d[14];
          const gessoTime = d[15];
          
          let presetTemp = 0;
          if(byte2 == 0x40)  presetTemp = dryTemp;
          if(byte2 == 0x60)  presetTemp = gessoTemp;
          if(byte2 == 0xA0)  presetTemp = dryTemp;
          if(byte2 == 0x30)  presetTemp = gessoTemp;

          const atomizerMap = {
            0x40: 'Gesso', 0x60: 'Gesso', 0xA0: 'Dry Herb', 0x30: 'Gesso Max', 0x00: 'No Atomizer'
          };
          const unitMap = {
            0x11: 'â„‰', 0x22: 'â„ƒ'
          };

          set('atomizer', atomizerMap[byte2] || `0x${byte2.toString(16)}`);
          set('dryPreset', byte4 >> 4);
          set('gessoPreset', byte4 & 0x0F);
          set('countdown', `${byte5}s`);
          set('curTemp', temp + unitMap[byte3]);
          set('presetTemp', presetTemp + unitMap[byte3]);
          set('battery', `${battery}%`);
          set('ledPreset', ledPreset);
          set('dryTime', `${dryTime}s`);
          set('gessoTime', `${gessoTime}s`);
          console.log('æ‰¾åˆ° Notify ç‰¹å¾å€¼:', char.uuid);
        });
      }

      if (char.properties.write || char.properties.writeWithoutResponse) {
        characteristicToWrite = char;
        console.log('æ‰¾åˆ° Write ç‰¹å¾å€¼:', char.uuid);
      }
    }

    alert("è“ç‰™è®¾å¤‡è¿æ¥æˆåŠŸï¼");

  } catch (e) {
    alert('è¿æ¥å¤±è´¥: ' + e);
  }
});

document.getElementById('startWifiBtn').addEventListener('click', async () => {
  const ssid = document.getElementById('ssid').value.trim();
  const password = document.getElementById('password').value.trim();
  if (!ssid) {
    alert("è¯·è¾“å…¥ SSID");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼ï¼Œè¯·å…ˆè¿æ¥è®¾å¤‡");
    return;
  }

  const data = new TextEncoder().encode(`wifi_${ssid} ${password}`);
  try {
    await characteristicToWrite.writeValue(data);
    alert("WiFi é…ç½®å·²å‘é€");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e);
  }
});

// ğŸŒŸ æ–°å¢: å¤„ç† Start OTA æŒ‰é’®ç‚¹å‡»
document.getElementById('startOtaBtn').addEventListener('click', async () => {
  const otaUrl = document.getElementById('otaUrl').value.trim();
  if (!otaUrl) {
    alert("è¯·è¾“å…¥ OTA ä¸‹è½½ URL");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼ï¼Œè¯·å…ˆè¿æ¥è®¾å¤‡");
    return;
  }

  const data = new TextEncoder().encode(`url_${otaUrl}`);
  try {
    await characteristicToWrite.writeValue(data);
    alert("OTA åœ°å€å·²å‘é€");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e);
  }
});

document.getElementById('sendHexBtn').addEventListener('click', async () => {
  const hexStr = document.getElementById('hexInput').value.trim();
  if (!hexStr) {
    alert("è¯·è¾“å…¥åå…­è¿›åˆ¶æ•°æ®");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Uint8Array
    const hexArray = hexStr.split(/\s+/).map(byte => {
      const num = parseInt(byte, 16);
      if (isNaN(num)) throw new Error(`æ— æ•ˆçš„åå…­è¿›åˆ¶æ•°: ${byte}`);
      return num;
    });
    const data = new Uint8Array(hexArray);
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ Hex æ•°æ®");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});
document.getElementById('sendAsciiBtn').addEventListener('click', async () => {
  const asciiStr = document.getElementById('hexInput').value.trim();
  if (!asciiStr) {
    alert("è¯·è¾“å…¥ ASCII å­—ç¬¦ä¸²");
    return;
  }

  if (!characteristicToWrite) {
    alert("æœªè¿æ¥è“ç‰™è®¾å¤‡æˆ–æœªæ‰¾åˆ°å¯å†™ç‰¹å¾å€¼");
    return;
  }

  try {
    const data = new TextEncoder().encode(asciiStr); // è½¬æˆ UTF-8 å­—èŠ‚æµ
    await characteristicToWrite.writeValue(data);
    alert("å·²å‘é€ ASCII å­—ç¬¦ä¸²");
  } catch (e) {
    alert("å‘é€å¤±è´¥: " + e.message);
  }
});



/* ---------- å°åŒ…ï¼šè¿”å› Uint8Array( 518 ) ---------- */
const PAYLOAD_SIZE = 16;        // æ¯å¸§æœ‰æ•ˆæ•°æ® 32B
const FRAME_SIZE   = 22;   // 1+2+16+2+1
const HEADER_BYTE  = 0xAA;
const TAIL_BYTE    = 0xAA;
function crc16Modbus(buf) {
  let crc = 0xFFFF;
  for (let b of buf) {
    crc ^= b;
    for (let i = 0; i < 8; ++i)
      crc = (crc & 1) ? (crc >>> 1) ^ 0xA001 : crc >>> 1;
  }
  return crc & 0xFFFF;
}
function buildSmallPacket(seq, payload32) {
  const frame = new Uint8Array(FRAME_SIZE);

  frame[0] = HEADER_BYTE;           // å¸§å¤´
  frame[1] = seq & 0xFF;           // Seq_L
  frame[2] = (seq >> 8) & 0xFF;    // Seq_H

  frame.fill(0xFF, 3);             // å…ˆæŠŠ 32B åŒºåŸŸå¡« 0xFF
  frame.set(payload32, 3);         // å†™å…¥å®é™…æ•°æ®

  const crc = crc16Modbus(frame.subarray(1, 1 + 2 + PAYLOAD_SIZE)); // Seq+Payload
  frame[19] = (crc >> 8) & 0xFF;    // CRC é«˜
  frame[20] =  crc & 0xFF;          // CRC ä½
  frame[21] = TAIL_BYTE;            // å¸§å°¾

  return frame;
}





/* ---------- é€‰æ‹© BIN â†’ åˆ†åŒ… â†’ å†™å…¥ ---------- */
document.getElementById('sendBinBtn').addEventListener('click', async () => {
  const f = document.getElementById('binFile').files[0];
  if (!f) { alert('è¯·é€‰æ‹© .bin æ–‡ä»¶'); return; }
  if (!characteristicToWrite) { alert('è¯·å…ˆè¿æ¥è“ç‰™è®¾å¤‡'); return; }

  try {
    const arrayBuf = await f.arrayBuffer();
    const bin = new Uint8Array(arrayBuf);
    const totalPkts = Math.ceil(bin.length / PAYLOAD_SIZE);

    // let seq = 0;
    // for (let offset = 0; offset < bin.length; offset += PAYLOAD_SIZE, seq++) {
    //   const remain = bin.length - offset;                 // å‰©ä½™å­—èŠ‚æ•°
    //   let slice;
    //   if (remain >= PAYLOAD_SIZE) {
    //     // æ­£å¸¸ 512 å­—èŠ‚
    //     slice = bin.subarray(offset, offset + PAYLOAD_SIZE);
    //   } else {
    //     // â­ æœ€åä¸€åŒ…ï¼šåˆ›å»º 512B ç¼“å†²ï¼Œå…ˆå…¨å¡« 0xFFï¼Œå†æ‹·è´å‰©ä½™æ•°æ®
    //     slice = new Uint8Array(PAYLOAD_SIZE).fill(0xFF);
    //     slice.set(bin.subarray(offset));                  // æŠŠå‰©ä½™å­—èŠ‚æ‹·è¿›å»
    //   }
    //  const slice = bin.subarray(offset, offset + PAYLOAD_SIZE);
   //   const packet = buildPacket(seq, slice);

      /* å¦‚ MTU < 518ï¼Œå¯åœ¨æ­¤å†æ‹†å°ç¢ç‰‡å†™ï¼›æ­¤å¤„å‡è®¾ MTU è¶³å¤Ÿ */
     // await characteristicToWrite.writeValue(packet);
      // === æ‹†æˆ 32 B å†™å‡º ===
      for (let offset = 0, seq = 0; offset < bin.length; offset += PAYLOAD_SIZE, ++seq) {
        /* ---- å– 32Bï¼Œä¸è¶³è¡¥ 0xFF ---- */
        const remain  = bin.length - offset;
        const block32 = remain >= PAYLOAD_SIZE
              ? bin.subarray(offset, offset + PAYLOAD_SIZE)
              : new Uint8Array(PAYLOAD_SIZE).fill(0xFF)
                    .map((v, i) => (i < remain ? bin[offset + i] : v));

        const pkt = buildSmallPacket(seq, block32);   // 38 B
        console.log(`Sending pkt data is, seq=${seq}, size=${pkt.length}, data=${[...pkt]}`);
        await characteristicToWrite.writeValue(pkt);  // ç›´æ¥å†™æ•´å¸§
        console.log(`Frame ${seq} sent, wait AWKâ€¦`);

        try {
          await waitForAck();                         // ä¸å‰è¿° ACK æœºåˆ¶ç›¸åŒ
        } catch (e) {
          alert(e.message); return;
        }
      }
      alert('OTA bin å…¨éƒ¨å‘é€å®Œæˆï¼');
    } 
  catch (e) {
    alert('å‘é€å¤±è´¥: ' + e.message);
  }
});

</script>

</body>
</html>
