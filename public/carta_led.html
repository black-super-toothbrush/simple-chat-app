<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BLE Scan & Connect</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 24px; background: #f7f7fb; color: #222; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .toolbar { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
    button { padding: 8px 14px; border-radius: 8px; border: 1px solid #8884; background: #4f7cff; color: #fff; cursor: pointer; }
    button:hover { filter: brightness(1.05); }
    #status { margin-top: 8px; font-size: 13px; color: #555; }
    .hint { font-size: 12px; color: #777; }
    .warn { color: #b45309; background: #fff7ed; border: 1px solid #fed7aa; padding: 8px 10px; border-radius: 8px; margin-top: 8px; display:none; }
  </style>
</head>
<body>
  <h1>Bluetooth Scan & Connect</h1>
  <div class="toolbar">
    <button id="scanBtn">Scan</button>
    <button id="ledPresetBtn" title="Cycle LED preset">LED Preset: 0</button>
    <button id="otaFlashBtn" title="Start OTA flashing">OTA Flash</button>
  </div>
  <div id="status">Ready</div>
  <div id="secureWarn" class="warn">This page is not served in a secure context. Web Bluetooth requires HTTPS or localhost.</div>

  <!-- LED Color Palettes -->
  <div class="card" style="margin-top:16px; padding:12px; background:#fff; border:1px solid #ddd; border-radius:12px;">
    <div style="font-weight:600; margin-bottom:8px;">LED Color Palettes</div>
    <div id="paletteGrid" style="display:grid; grid-template-columns:repeat(4, minmax(160px, 1fr)); gap:12px;">
      <label style="display:flex; align-items:center; gap:8px;">Color 1 <input id="color1" type="color" value="#ff0000" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="0" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 2 <input id="color2" type="color" value="#00ff00" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="1" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 3 <input id="color3" type="color" value="#0000ff" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="2" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 4 <input id="color4" type="color" value="#ffff00" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="3" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 5 <input id="color5" type="color" value="#ff00ff" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="4" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 6 <input id="color6" type="color" value="#00ffff" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="5" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 7 <input id="color7" type="color" value="#ffffff" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="6" style="padding:6px 10px;">Apply</button></label>
      <label style="display:flex; align-items:center; gap:8px;">Color 8 <input id="color8" type="color" value="#000000" style="width:44px; height:28px; padding:0; border:none; background:none;" /> <button class="apply-btn" data-idx="7" style="padding:6px 10px;">Apply</button></label>
    </div>
    <div id="rgbLabel" class="hint" style="margin-top:10px;">RGB: 255, 0, 0</div>
  </div>

  <!-- OTA Flash (Telink) -->
  <div class="card" style="margin-top:16px; padding:12px; background:#fff; border:1px solid #ddd; border-radius:12px;">
    <div style="font-weight:600; margin-bottom:8px;">OTA Flash</div>
    <div id="otaPercent" class="hint">Status: waiting for you to connect a device</div>
    <div id="otaLog" style="font-size:12px; color:#555; margin-top:8px; max-height:160px; overflow:auto; border-top:1px dashed #ddd; padding-top:8px;"></div>
  </div>

  <script>
    const scanBtn = document.getElementById('scanBtn');
    const ledPresetBtn = document.getElementById('ledPresetBtn');
    const otaFlashBtn = document.getElementById('otaFlashBtn');
    const statusEl = document.getElementById('status');
    const secureWarnEl = document.getElementById('secureWarn');

    let connectedDevice = null;
    let gattServer = null;
    let ledCharacteristic = null;
    let ledNotifyCharacteristic = null;
    let ledPreset = 0; // 0-5
    const LED_SERVICE_UUID = '1011123e-8535-b5a0-7140-a304d2495cb7';
    const LED_CHAR_UUID = '1011123e-8535-b5a0-7140-a304d2495cb9';
    const LED_NOTIFY_CHAR_UUID = '1011123e-8535-b5a0-7140-a304d2495cb8';
    // Telink OTA UUIDs (same as TelinkOTA.html)
    const OTA_SERVICE_UUID = '00010203-0405-0607-0809-0a0b0c0d1912';
    const OTA_CHAR_UUID = '00010203-0405-0607-0809-0a0b0c0d2b12';
    let otaWriteCharacteristic = null;
    let otaFirmwareHex = '';
    let otaStartTime = 0;
    let otaBlockCount = 0;

    function setStatus(msg) {
      statusEl.textContent = msg;
      console.log('[Status]', msg);
    }
    function hexDumpFromDataView(dv) {
      const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
    }
    // ----- Telink OTA helpers -----
    function otaAddLog(txt) {
      const el = document.getElementById('otaLog');
      const time = new Date().toLocaleTimeString();
      el.innerHTML += `${time}: ${txt}<br>`;
      el.scrollTop = el.scrollHeight;
    }
    function otaSetStatus(s) {
      const el = document.getElementById('otaPercent');
      el.textContent = `Status: ${s}`;
    }
    function decimalToHex(d) {
      let hex = Number(d).toString(16);
      while (hex.length < 4) hex = '0' + hex;
      return hex;
    }
    function hexToBytes(hex) {
      const bytes = [];
      for (let c = 0; c < hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16));
      return new Uint8Array(bytes);
    }
    function bytesToHex(data) {
      return new Uint8Array(data).reduce((memo, i) => memo + ('0' + i.toString(16)).slice(-2), '');
    }
    function crc16_modbus(buffer) {
      let crc = 0xFFFF; let odd;
      for (let i = 0; i < buffer.length; i++) {
        crc = crc ^ buffer[i];
        for (let j = 0; j < 8; j++) {
          odd = crc & 0x0001; crc = crc >> 1; if (odd) crc = crc ^ 0xA001;
        }
      }
      return crc;
    }
    function otaGetHexCRC(hexStr) {
      const tempCRC = decimalToHex(crc16_modbus(hexToBytes(hexStr)));
      return tempCRC.substring(2, 4) + tempCRC.substring(0, 2);
    }
    function otaGetHexBlockCount(count) {
      const tempHEX = decimalToHex(count);
      return tempHEX.substring(2, 4) + tempHEX.substring(0, 2);
    }
    async function otaFetchFirmwareAndPrepare() {
      otaAddLog('Loading firmware: carta_led.bin');
      const resp = await fetch('carta_led.bin');
      if (!resp.ok) throw new Error('Firmware not found: carta_led.bin');
      const buf = await resp.arrayBuffer();
      otaFirmwareHex = bytesToHex(buf);
      otaAddLog(`File size: ${otaFirmwareHex.length / 2} bytes`);
      // pad last block to 16 bytes (32 hex chars) if needed
      if (otaFirmwareHex.length % 32 !== 0) {
        const padHex = 'ffffffffffffffffffffffffffffffff';
        otaFirmwareHex += padHex.substr(0, 32 - (otaFirmwareHex.length % 32));
      }
      otaBlockCount = otaFirmwareHex.length / 32;
      otaAddLog(`Count: ${otaBlockCount}`);
    }
    function otaCharSend(hexStr) {
      return new Promise((resolve, reject) => {
        otaWriteCharacteristic.writeValueWithoutResponse(hexToBytes(hexStr))
          .then(() => resolve('ok'))
          .catch(() => reject('some error while sending char data'));
      });
    }
    async function otaUpdateBegin() {
      if (otaBlockCount <= 0) { otaAddLog('No file selected aborting'); return; }
      otaSetStatus('Preparing...');
      await new Promise(r => setTimeout(r, 500));
      try {
        await otaCharSend('00ff');
        await otaCharSend('01ff');
        otaStartTime = Date.now();
        await new Promise(r => setTimeout(r, 300));
        otaSendBlock(0);
      } catch (err) {
        otaUpdateFail(err);
      }
    }
    function otaUpdateFail(err) {
      const s = `Update error: ${err}`;
      otaAddLog(s); otaSetStatus(s);
    }
    function otaSendBlock(blockNr) {
      if (blockNr >= otaBlockCount) { otaSendLast(); return; }
      otaSetStatus(`Sending block nr: ${blockNr} from ${otaBlockCount}, ${Math.floor(blockNr / (otaBlockCount * 1.0) * 100)}% done, time since start ${( (Date.now() - otaStartTime) / 1000.0).toFixed(2)}s`);
      const blockNrString = otaGetHexBlockCount(blockNr);
      const blockString = blockNrString + otaFirmwareHex.substring(blockNr * 32, blockNr * 32 + 32);
      const blockCRC = otaGetHexCRC(blockString);
      otaCharSend(blockString + blockCRC).then(() => {
        setTimeout(() => {
          if ((blockNr + 1) % 8 === 0) {
            otaWriteCharacteristic.readValue().then(() => {
              otaSendBlock(blockNr + 1);
            }).catch(err => otaUpdateFail(err));
          } else {
            otaSendBlock(blockNr + 1);
          }
        }, 0);
      }).catch(err => otaUpdateFail(err));
    }
    function otaSendLast() {
      const data = '02ff' + otaGetHexBlockCount(otaBlockCount - 1) + otaGetHexBlockCount(~(otaBlockCount - 1) & 0xffff);
      otaCharSend(data).then(() => {
        const s = `Update done after ${(Date.now() - otaStartTime) / 1000} seconds`;
        otaAddLog(s); otaSetStatus(s);
      }).catch(err => otaUpdateFail(err));
    }
    async function startOtaFlash() {
      try {
        if (!gattServer) { setStatus('Connect a BLE device first'); return; }
        const service = await gattServer.getPrimaryService(OTA_SERVICE_UUID);
        otaWriteCharacteristic = await service.getCharacteristic(OTA_CHAR_UUID);
        otaAddLog('Found write characteristic');
        otaSetStatus('Connected.');
        await otaFetchFirmwareAndPrepare();
        otaAddLog('Start DFU');
        await otaUpdateBegin();
      } catch (err) {
        otaUpdateFail(err);
      }
    }
    // Send a clock calibration frame (0xDD) after connection
    async function sendClockCalibrationDD(char) {
      try {
        const now = new Date();
        const year = now.getFullYear();
        const yh = (year >> 8) & 0xFF; // high byte
        const yl = year & 0xFF;        // low byte
        let month = now.getMonth() + 1; // 1-12
        let day = now.getDate();        // 1-31 (doc shows 1-30)
        let hour = now.getHours();      // 0-23
        let minute = now.getMinutes();  // 0-59
        // clamp per spec from provided table
        month = Math.min(12, Math.max(1, month));
        day = Math.min(30, Math.max(1, day));
        hour = Math.min(24, Math.max(1, hour)); // table shows 0x01-0x18
        minute = Math.min(59, Math.max(0, minute));
        const payload = new Uint8Array([
          0xDD, 0x0C, yh, yl, month, day, hour, minute, 0x00, 0x00, 0x00, 0xDD
        ]);
        if (typeof char.writeValue === 'function') {
          await char.writeValue(payload);
        } else if (typeof char.writeValueWithoutResponse === 'function') {
          await char.writeValueWithoutResponse(payload);
        } else {
          throw new Error('Characteristic does not support write');
        }
        console.log('已发送 0xDD 时钟校准帧:', payload);
        setStatus('Sent 0xDD clock calibration');
      } catch (err) {
        console.error('0xDD write failed', err);
        setStatus(`0xDD write failed: ${err.message || err}`);
      }
    }
    function handleLedNotify(event) {
      try {
        const dv = event.target.value;
        // Debug: print all received bytes in HEX
        console.debug('[Notify HEX]', hexDumpFromDataView(dv));
        const len = dv.byteLength;
        // Preset update: EB 04 led_preset EB
        if (len >= 4) {
          const s2 = dv.getUint8(0);
          const c2 = dv.getUint8(1);
          const p2 = dv.getUint8(2);
          const e2 = dv.getUint8(3);
          if (s2 === 0xEB && c2 === 0x04 && e2 === 0xEB && p2 >= 0 && p2 <= 5) {
            ledPreset = p2;
            if (ledPresetBtn) ledPresetBtn.textContent = `LED Preset: ${ledPreset}`;
            setStatus(`LED preset updated: ${ledPreset}`);
            return;
          }
        }
        // LED color frame: EA 07 idx R G B EA
        if (len >= 7) {
          const start = dv.getUint8(0);
          const cmd = dv.getUint8(1);
          const idx = dv.getUint8(2);
          const r = dv.getUint8(3);
          const g = dv.getUint8(4);
          const b = dv.getUint8(5);
          const end = dv.getUint8(6);
          if (start !== 0xEA || cmd !== 0x07 || end !== 0xEA) return;
          if (idx < 0 || idx > 7) return;
          const hex = '#' + [r,g,b].map(v => v.toString(16).padStart(2, '0')).join('');
          const inputEl = document.querySelector(`#paletteGrid input#color${idx+1}`);
          if (inputEl) {
            inputEl.value = hex;
          }
          const rgbLabelEl = document.getElementById('rgbLabel');
          if (rgbLabelEl) {
            rgbLabelEl.textContent = `RGB: ${r}, ${g}, ${b}`;
          }
          setStatus(`LED ${idx} color updated from device`);
          return;
        }
      } catch (e) {
        console.error('Notify parse error', e);
      }
    }

    async function onScanClick() {
      if (!navigator.bluetooth) {
        setStatus('Web Bluetooth is not supported in this browser');
        return;
      }
      try {
        setStatus('Opening device chooser...');
        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: ['1011123e-8535-b5a0-7140-a304d2495cb7', OTA_SERVICE_UUID]
        });
        setStatus(`Connecting to ${device.name || device.id} ...`);
        const server = await device.gatt.connect();
        gattServer = server;
        connectedDevice = device;
        setStatus(`Connected: ${device.name || device.id}`);
        console.log('GATT Server:', server);

        // Get LED service & characteristic
        try {
          const service = await server.getPrimaryService(LED_SERVICE_UUID);
          ledCharacteristic = await service.getCharacteristic(LED_CHAR_UUID);
          // Show connected & LED ready before subscribing notifications
          setStatus(`Connected: ${device.name || device.id} (LED ready)`);
          // 连接成功后立即发送一帧 0xDD（时钟校准）
          try {
            await sendClockCalibrationDD(ledCharacteristic);
          } catch (e) {
            console.warn('发送 0xDD 帧失败', e);
          }
          // 参考 carta2 的方式：遍历服务的特征并订阅所有支持 notify 的特征
          try {
            const characteristics = await service.getCharacteristics();
            let notifyCount = 0;
          for (const char of characteristics) {
            console.log('特征值 UUID:', char.uuid, 'Properties:', char.properties);
            if (char.properties && char.properties.notify) {
              // 先绑定监听再开启通知，尽量避免丢失首帧
              char.addEventListener('characteristicvaluechanged', event => {
                const dv = event.target.value;
                const d = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
                console.log('收到 Notify 数据:', d);
                console.debug('[Notify HEX]', hexDumpFromDataView(dv));
                try { handleLedNotify(event); } catch (e) { console.error('handleLedNotify error', e); }
              });
              try {
                await char.startNotifications();
              } catch (e) {
                console.warn('startNotifications 失败', e);
              }
              // 如果支持 read，订阅后尝试读取一次当前值
              try {
                const v = await char.readValue();
                console.debug('[Initial READ HEX]', hexDumpFromDataView(v));
              } catch (readErr) {
                console.debug('Read 不支持或失败（notify-only characteristic）', readErr);
              }
              // 记录目标通知特征，便于后续使用
              if (char.uuid === LED_NOTIFY_CHAR_UUID) {
                ledNotifyCharacteristic = char;
              }
              notifyCount++;
            }
            }
            if (notifyCount > 0) {
              setStatus('LED notifications enabled; waiting for data...');
            } else {
              console.warn('该服务下没有支持 notify 的特征');
            }
          } catch (notifErr) {
            console.warn('遍历并开启 notify 失败', notifErr);
          }
        } catch (e) {
          console.error('Failed to get LED characteristic', e);
          setStatus(`Connected: ${device.name || device.id}, but LED characteristic not found`);
        }
        // Example: read a characteristic after connected
        // const service = await server.getPrimaryService('battery_service');
        // const char = await service.getCharacteristic('battery_level');
        // const value = await char.readValue();
      } catch (err) {
        if (err && err.name === 'NotFoundError') {
          setStatus('User cancelled selection');
        } else {
          console.error(err);
          setStatus(`Connection failed: ${err.message || err}`);
        }
      }
    }

    scanBtn.addEventListener('click', onScanClick);

    // Disconnection handler
    navigator.bluetooth.addEventListener?.('gattserverdisconnected', (ev) => {
      const dev = ev.target;
      setStatus(`Disconnected: ${dev?.name || dev?.id || 'device'}`);
      ledCharacteristic = null;
      ledNotifyCharacteristic = null;
    });

    // Environment hint
    window.addEventListener('load', () => {
      if (!isSecureContext) {
        secureWarnEl.style.display = 'block';
      }
      // LED preset button init and click handler
      if (ledPresetBtn) {
        ledPresetBtn.textContent = `LED Preset: ${ledPreset}`;
        ledPresetBtn.addEventListener('click', async () => {
          ledPreset = (ledPreset + 1) % 6; // 0-5
          ledPresetBtn.textContent = `LED Preset: ${ledPreset}`;
          if (!ledCharacteristic) {
            setStatus('Connect a BLE device first');
            return;
          }
          const payload = new Uint8Array([0xE6, 0x04, ledPreset, 0xE6]);
          try {
            if (typeof ledCharacteristic.writeValue === 'function') {
              await ledCharacteristic.writeValue(payload);
            } else if (typeof ledCharacteristic.writeValueWithoutResponse === 'function') {
              await ledCharacteristic.writeValueWithoutResponse(payload);
            } else {
              throw new Error('Characteristic does not support write');
            }
            setStatus(`LED preset set to ${ledPreset}`);
          } catch (err) {
            console.error('Write preset failed', err);
            setStatus(`Write preset failed: ${err.message || err}`);
          }
        });
      }
      // OTA Flash button
      if (otaFlashBtn) {
        otaFlashBtn.addEventListener('click', startOtaFlash);
      }
      // bind color inputs
      const labels = Array.from(document.querySelectorAll('#paletteGrid input[type="color"]'));
      const applyButtons = Array.from(document.querySelectorAll('#paletteGrid .apply-btn'));
      const rgbLabel = document.getElementById('rgbLabel');
      const colorHexes = new Array(8);
      const hexToRgb = (hex) => {
        const h = hex.replace('#','');
        const bigint = parseInt(h, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return { r, g, b };
      };
      const onChange = (ev, ledIndex) => {
        const { r, g, b } = hexToRgb(ev.target.value);
        rgbLabel.textContent = `RGB: ${r}, ${g}, ${b}`;
        colorHexes[ledIndex] = ev.target.value;
      };
      labels.forEach((el, idx) => el.addEventListener('input', (ev) => onChange(ev, idx)));
      // init saved colors
      labels.forEach((el, idx) => colorHexes[idx] = el.value);
      // Apply button -> write BLE only when clicked
      applyButtons.forEach((btn) => {
        btn.addEventListener('click', async () => {
          const idx = Number(btn.dataset.idx);
          if (!ledCharacteristic) {
            setStatus('Connect a BLE device first');
            return;
          }
          const hex = labels[idx]?.value;
          const { r, g, b } = hexToRgb(hex);
          const payload = new Uint8Array([0xE5, 0x07, idx, r, g, b, 0xE5]);
          try {
            if (typeof ledCharacteristic.writeValue === 'function') {
              await ledCharacteristic.writeValue(payload);
            } else if (typeof ledCharacteristic.writeValueWithoutResponse === 'function') {
              await ledCharacteristic.writeValueWithoutResponse(payload);
            } else {
              throw new Error('Characteristic does not support write');
            }
            setStatus(`LED ${idx} color applied`);
          } catch (err) {
            console.error('Write failed', err);
            setStatus(`Write failed: ${err.message || err}`);
          }
        });
      });
      // init with first color
      if (labels[0]) {
        const { r, g, b } = hexToRgb(labels[0].value);
        rgbLabel.textContent = `RGB: ${r}, ${g}, ${b}`;
      }
    });
  </script>
</body>
</html>